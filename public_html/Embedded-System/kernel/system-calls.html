<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>System calls</title>
<!-- 2015-03-05 Thu 23:20 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>

<script type="text/javascript" src="assets/js/org-info.js">
/**
 *
 * @source: assets/js/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in assets/js/org-info.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in assets/js/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "2");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "0");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "#dddddd");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "showall");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">System calls</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Basics of System Programming</a>
<ul>
<li><a href="#sec-1-1">Tracing System Calls</a></li>
<li><a href="#sec-1-2">Supported Standards</a></li>
<li><a href="#sec-1-3">Restarting System Calls</a></li>
</ul>
</li>
<li><a href="#sec-2">Available System Calls</a>
<ul>
<li><a href="#sec-2-1">Process Management</a></li>
<li><a href="#sec-2-2">Time Operations</a></li>
<li><a href="#sec-2-3">Signal Handling</a></li>
<li><a href="#sec-2-4">Scheduling</a></li>
<li><a href="#sec-2-5">Modules</a></li>
<li><a href="#sec-2-6">Filesystem</a></li>
<li><a href="#sec-2-7">Memory Management</a></li>
<li><a href="#sec-2-8">Interprocess Communication and Network Functions</a></li>
<li><a href="#sec-2-9">System Information and Settings</a></li>
<li><a href="#sec-2-10">System Security and Capabilities</a></li>
</ul>
</li>
<li><a href="#sec-3">Implementation of System Calls</a>
<ul>
<li><a href="#sec-3-1">Structure of System Calls</a></li>
<li><a href="#sec-3-2">Access to Userspace</a></li>
<li><a href="#sec-3-3">System Call Tracing</a></li>
<li><a href="#sec-3-4">Stopping Tracing</a></li>
</ul>
</li>
<li><a href="#sec-4">reference</a>
<ul>
<li><a href="#sec-4-1"><code>ptrace_attach</code></a></li>
<li><a href="#sec-4-2"><code>ptrace_detach</code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
用户程序看来,kernel是一个透明的系统层,它一直在那却不被注意.进程不知道
kernel是否运行.然而,进程一直与kernel交互着请求系统资源,访问外围设备,与其他进程通信,读文件等等.为达到这写目的,它们使用标准库函数来调用内核函数.
</p>

<p>
系统调用(system calls)被用来调用内核函数从用户应用.这里主要分析一下
system call如何与标准库相关,运行机制,如何实现等.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Basics of System Programming</h2>
<div class="outline-text-2" id="text-1">
<p>
随着编程语言趋于更高层的抽象化,系统编程的真正意义慢慢被腐蚀.为什么要麻烦去理解系统细节呢.拥有千兆字节或兆兆字节数据的数据库需要知道底层操作系统使用什么机制读取它们的文件和原始数据,以至修改数据库代码达到最大化的执行.
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Tracing System Calls</h3>
<div class="outline-text-3" id="text-1-1">
<p>
如下例子来看system calls如何被封装在标准库中然后被调用:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span><span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span><span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #b0c4de;">#include</span><span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #b0c4de;">#include</span><span style="color: #ffa07a;">&lt;malloc.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">handle</span>, <span style="color: #eedd82;">bytes</span>;
  <span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">ptr</span>;
  handle = open(<span style="color: #ffa07a;">"/tmp/test.txt"</span>, O_RDONLY);
  ptr = (<span style="color: #98fb98;">void</span>*)malloc(150);
  bytes = read(handle, ptr, 150);
  printf(<span style="color: #ffa07a;">"%s"</span>, ptr);
  close(handle);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
多少个系统调用被这个程序所使用呢?初看有 <code>open</code>, <code>read</code>, <code>close</code>.
</p>

<p>
使用工具 <code>strace</code> 可以记录应用使用的所有系统调用.如下对上面的 <code>test</code>
做记录:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ strace -o log.txt ./test
</pre>
</div>

<p>
<code>log.txt</code> 的内容如下:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #87cefa;">execve</span>(<span style="color: #ffa07a;">"./test"</span>, [<span style="color: #ffa07a;">"./test"</span>], [/* 47 vars */]) = 0
<span style="color: #87cefa;">brk</span>(0)                                  = 0x9111000
<span style="color: #87cefa;">access</span>(<span style="color: #ffa07a;">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)
<span style="color: #87cefa;">mmap2</span>(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7729000
<span style="color: #87cefa;">access</span>(<span style="color: #ffa07a;">"/etc/ld.so.preload"</span>, R_OK)      = -1 ENOENT (No such file or directory)
<span style="color: #87cefa;">open</span>(<span style="color: #ffa07a;">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = 3
<span style="color: #87cefa;">fstat64</span>(3, {<span style="color: #eedd82;">st_mode</span>=S_IFREG|0644, <span style="color: #eedd82;">st_size</span>=100251, ...}) = 0
<span style="color: #87cefa;">mmap2</span>(NULL, 100251, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7710000
<span style="color: #87cefa;">close</span>(3)                                = 0
<span style="color: #87cefa;">access</span>(<span style="color: #ffa07a;">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)
<span style="color: #87cefa;">open</span>(<span style="color: #ffa07a;">"/lib/i386-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = 3
<span style="color: #b0c4de;">read</span>(3, <span style="color: #ffa07a;">"\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\226\1\0004\0\0\0"</span>..., 512) = 512
<span style="color: #87cefa;">fstat64</span>(3, {<span style="color: #eedd82;">st_mode</span>=S_IFREG|0755, <span style="color: #eedd82;">st_size</span>=1734120, ...}) = 0
<span style="color: #87cefa;">mmap2</span>(NULL, 1743580, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7566000
<span style="color: #87cefa;">mmap2</span>(0xb770a000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1a4) = 0xb770a000
<span style="color: #87cefa;">mmap2</span>(0xb770d000, 10972, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb770d000
<span style="color: #87cefa;">close</span>(3)                                = 0
<span style="color: #87cefa;">mmap2</span>(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7565000
<span style="color: #87cefa;">set_thread_area</span>({entry_number:-1 -&gt; 6, base_addr:0xb7565900, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
<span style="color: #87cefa;">mprotect</span>(0xb770a000, 8192, PROT_READ)   = 0
<span style="color: #87cefa;">mprotect</span>(0x8049000, 4096, PROT_READ)    = 0
<span style="color: #87cefa;">mprotect</span>(0xb774c000, 4096, PROT_READ)   = 0
<span style="color: #87cefa;">munmap</span>(0xb7710000, 100251)              = 0
<span style="color: #87cefa;">open</span>(<span style="color: #ffa07a;">"/tmp/test.txt"</span>, O_RDONLY)         = -1 ENOENT (No such file or directory)
<span style="color: #87cefa;">brk</span>(0)                                  = 0x9111000
<span style="color: #87cefa;">brk</span>(0x9132000)                          = 0x9132000
<span style="color: #b0c4de;">read</span>(-1, 0x9111008, 150)                = -1 EBADF (Bad file descriptor)
<span style="color: #87cefa;">close</span>(-1)                               = -1 EBADF (Bad file descriptor)
<span style="color: #87cefa;">exit_group</span>(0)                           = ?
</pre>
</div>

<p>
trace log显示这个应用程序使用了一大堆不是明显在源代码中的系统调用.所以两者有着强烈的依赖关系.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Supported Standards</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在Unix类的系统中,system calls是比较重要地位的.她们的范围和速度,实现的效率在系统执行中占有很多的重要角色.Unix的分支众多,不同的标准提出来规范它们系统调用的接口.
</p>

<p>
POSIX标准(Portable Operating System Interface forUnix)成为主要的标准.Linux和C标准库都极力与它兼容.
</p>

<p>
除了POSIX,在UNIX历史中,2大主要发展线路: System V(来自于初始AT&amp;T代码)
和BSD(Berkeley Software Distribution由University of California开发,现在以NetBSD, FreeBSD, OpenBSD, BSDI 和 MacOS X为代表).
</p>

<p>
Linux形成它自己独立的system calls从如上所有三者.比如,如下3个有名的
system calls源自于这3大阵营:
</p>
<ul class="org-ul">
<li><code>flock</code> 锁文件防止多个进程并行访问.来自POSIX标准.
</li>
<li>BSD UNIX提供 <code>truncate</code> 调用来节短一个文件.Linux也以同样名字实现这个函数.
</li>
<li><code>sysfs</code> 收集文件系统的信息由System V Release 4引入.Linux也采用这个
system call.
</li>
</ul>

<p>
一些system calls被三个标准同时要求.比如 <code>time</code>, <code>gettimeofday</code> 等.
</p>

<p>
同样,一些system calls只在Linux特定开发,不存在其他标准中.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Restarting System Calls</h3>
<div class="outline-text-3" id="text-1-3">
<p>
当system calls与signals发生冲突时,有趣的问题就产生了.当一个system call
正在被执行,同时一个紧急的signal被发送到这个进程,那么两者的优先执行怎么处理?是signal等待直到system call终结,还是调用被中断以致signal能尽快被传递?第一种选择明显触发极少问题,并且是更简单的方法.不幸的是,它仅仅适用当所有system calls快速的终结并且不让进程等待太长时间.但这并不总是如此.System calls不仅需要一定的时间来执行,而且在最差的情况下,它们也会进入睡眠.这样的情况必须被防止.
</p>

<p>
如果执行中的system call被中断,kernel返回什么值给应用呢?在正常情况,只有
2中情况:调用不是成功就是失败.在中断情况中,第三种情况产生:应用被告知
system call在执行中被signal中断.在此情况下, <code>-EINTR</code> 被使用.
</p>

<p>
此种过程的缺点也是明显的.尽管它容易被实现,但它强制要求用户应用编程者明显的检查所有被中断system call的返回值是否是 <code>-EINTR</code>. 如果是这个值的话,就重新不断重启这个call直到不被signal中断.System calls以这种情况重启被称为 restartable system calls.
</p>

<p>
这种行为由System V Unix引入和采用,也是Linux默认的方式.但BSD不采用此方法,当此情况发生,call不返回值而是kernel自动重启这个call当signal处理终结.Linux通过 <code>SA_RESTART</code> 标示来支持BSD这种方式.
</p>

<p>
看如下例子看两者的区别:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signaled</span> = 0;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">handler</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signum</span>) {
  printf(<span style="color: #ffa07a;">"signaled called\n"</span>);
  signaled = 1;
}
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">ch</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sigaction</span> <span style="color: #eedd82;">sigact</span>;
  sigact.sa_handler = handler;
  sigact.sa_flags = SA_RESTART;
  sigaction(SIGINT, &amp;sigact, <span style="color: #7fffd4;">NULL</span>);
  <span style="color: #00ffff;">while</span> (read(STDIN_FILENO, &amp;ch, 1) != 1 &amp;&amp; !signaled);
}
</pre>
</div>

<p>
有个while循环,满足如下条件之一程序完成:
</p>
<ul class="org-ul">
<li>read到一个字节.
</li>
<li>变量signaled被设置为1.
</li>
</ul>

<p>
先注释掉 <code>sigact.sa_flags = SA_RESTART;</code> ,看System V下如何,运行程序,CTRL-C去中断它,signaled被设置,程序退出.
</p>

<p>
BSD下,运行程序,CTRL-C去中断它,signal处理得到调用并打印,BSD机制重启read
操作,并且!signaled没有被有效,程序不能在被SIGNIT signal终结.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Available System Calls</h2>
<div class="outline-text-2" id="text-2">
<p>
每个system call有符号定植表示,它们的平台依赖定义在
<code>&lt;asm-arch/unistd.h&gt;</code>,大约到达200个.最后把system calls按照功能分类使得编程者更容易使用.如下提取主要的system calls分类:
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Process Management</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>fork and vfork split an existing process into two new processes as.
clone is an enhanced version offorkthat supports, among other
things, the generation of threads.
</li>
<li>exit ends a process and frees its resources.
</li>
<li>A whole host of system calls exist to query (and set) process
properties such as PID, UID, and so on.; most of these calls simply
read or modify a field in the task structure. The following can be
read: PID, GID, PPID, SID, UID, EUID, PGID, EGID, and PGRP. The
following can be set: UID, GID, REUID, REGID, SID, SUID, and FSGID.
System calls are named in accordance with a logical scheme that uses
designations such as setgid,setuid,and geteuid.
</li>
<li>personality defines the execution environment of an application and
is used, for instance, in the implementation of binary emulations.
</li>
<li>ptrace enables system call tracing and is the platform on which the
above strace tool builds.
</li>
<li>nice sets the priority of normal processes by assigning a number
between −20 and 19 in descending order of importance. Only root
processes (or processes with theCAP<sub>SYS</sub><sub>NICE</sub> permission) are allowed
to specify negative values.
</li>
<li>setrlimitis used to set certain resource limits, for example, CPU
time or the maximum permitted number of child
processes.getrlimitqueries the current limits (i.e., maximum
permitted values), and getrusage queries current resource usage to
check whether the process is still within the defined resource
limits.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Time Operations</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>adjtimex reads and sets time-based kernel variables to control
kernel time behavior.
</li>
<li>alarm and setitimer set up alarms and interval timers to defer
actions to a later time. getitimer reads settings.
</li>
<li>gettimeofday and settimeofday get and set the current system time,
respectively. Unlike times, they also take account of the current
time zone and daylight saving time.
</li>
<li>sleep and nanosleep suspend process execution for a defined
interval;nanosleepdefines high-precision intervals.
</li>
<li>time returns the number of seconds since midnight on January 1, 1970
(this date is the classic time base for Unix systems).stimesets this
value and therefore changes the current system date.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Signal Handling</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>signal installs signal handler functions.sigaction is a modern,
enhanced version that supports additional options and provides
greater flexibility.
</li>
<li>sigpending checks whether signals are pending for the process but
are currently blocked.
</li>
<li>sigsuspend places the process on the wait queue until a specific
signal (from a set of signals) arrives.
</li>
<li>setmask enables signal blocking, whilegetmaskreturns a list of all
currently blocked signals.
</li>
<li>killis used to send any signals to a process.
</li>
<li>The same system calls are available to handle real-time signals.
However, their function names are prefixed with <code>rt_</code>. For example,
<code>rt_sigaction</code> installs a real-time signal handler,
and <code>rt_sigsuspend</code> puts the process in a wait state until a specific
signal (from a set of signals) arrives.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Scheduling</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>setpriority and getpriority set and get the priority of a process
and are therefore key system calls for scheduling purposes.
</li>
<li><code>sched_setscheduler</code> and <code>sched_getscheduler</code> set and query
scheduling classes. <code>sched_setparam</code> and <code>sched_getparam</code> set and
query additional scheduling parameters of processes (currently, only
the parameter for real-time priority is used).
</li>
<li><code>sched_yield</code> voluntarily relinquishes control even when CPU time is
still available to the process.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Modules</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li><code>init_module</code> adds a new module.
</li>
<li><code>delete_module</code> removes a module from the kernel.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Filesystem</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>Some system calls are used as a direct basis for userspace utilities
of the same name that create and modify the directory
structure:chdir, mkdir,rmdir,rename,symlink,getcwd,
chroot,umask,andmknod.
</li>
<li>File and directory attributes can be modified using chown and chmod.
</li>
<li>The following utilities for processing file contents are implemented
in the standard library and have the same names as the system
calls:open, close, readandreadv, writeand writev,truncate and llseek.
</li>
<li>readdir and getdents read directory structures.
</li>
<li>link,symlink,and unlink create and delete links (or files if they
are the last element in a hard link);readlink reads the contents of
a link.
</li>
<li>mount and umount are used to attach and detach filesystems.
</li>
<li>poll and select are used to wait for some event.
</li>
<li>execve loads a new process in place of an old process. It starts new
programs when used in conjunction with fork.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Memory Management</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>In terms of dynamic memory management, the most important call
is <code>brk</code>, which modifies the size of the process data segment. Programs
that invokemallocor similar functions (almost all nontrivial code)
make frequent use of this system call.
</li>
<li>mmap, mmap2, munmap,and mremap perform mapping, unmapping, and
remapping operations, while mprotect and madvise control access to and
give advice about specific regions of virtual memory.
</li>
<li>swapon and swapoff enable and disable (additional) swap space on
external storage devices.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Interprocess Communication and Network Functions</h3>
<div class="outline-text-3" id="text-2-8">
<ul class="org-ul">
<li>socketcall deals with network questions and is used to implement
socket abstraction.
</li>
<li>ipc is the counterpart to socketcall and is used for process
connections local to the computer and not for connections
established via networks.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">System Information and Settings</h3>
<div class="outline-text-3" id="text-2-9">
<ul class="org-ul">
<li>syslog writes messages to the system logs and permits the assignment
of different priorities.
</li>
<li>sysinfo returns information on the state of the system, particularly
statistics on memory usage.
</li>
<li>sysctlis used to ‘‘fine-tune‘‘ kernel parameters. 
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">System Security and Capabilities</h3>
<div class="outline-text-3" id="text-2-10">
<ul class="org-ul">
<li>capset and capgetare responsible for setting and querying process
capabilities.
</li>
<li>securityis a system call multiplexer for implementing LSM.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Implementation of System Calls</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Structure of System Calls</h3>
<div class="outline-text-3" id="text-3-1">
<p>
实现system calls的代码分为2部分.system call调用的任务是以C实现的,与其他kernel代码一样.但其中是对平台特定的特性和对许多细节处理的封装,最终以汇编代码实现.
</p>
</div>
<ul class="org-ul"><li><a id="sec-3-1-1" name="sec-3-1-1"></a>Implementation of Handler Functions<br  /><div class="outline-text-4" id="text-3-1-1">
<p>
这些函数分布在kernel中,因为它们是嵌入code sections中的,所以它们以它们目的文件紧密相连.比如,文件相关的system calls在 <code>fs/</code> kernel子目录中,因为它们与虚拟系统交互.同样所有内存管理调用在 <code>mm/</code> 子目录中.
</p>

<p>
用来实现system calls的处理函数共享一些格式:
</p>
<ul class="org-ul">
<li>每个函数以 <code>sys_</code> 为前缀表明函数是system call.
</li>
<li>所有处理函数最多接受5个参数.
</li>
<li>所有system calls执行在kernel模式下.
</li>
</ul>

<p>
在kernel与user模式之间转换有平台特定的代码实现,而处理函数 <code>handler</code> 基本以平台不相关代码实现,这样就把处理函数与平台特定的代码独立开来,实现它与其他内核代码类似.system call的基本调用流程如下:
</p>


<div class="figure">
<p><img src="./Files/sequence-system-call.jpeg" alt="sequence-system-call.jpeg" />
</p>
</div>

<p>
一些system calls比较简单,一些比较复杂,一些作为多路器.如下简单的和作为多路器的例子:
</p>
<div class="org-src-container">

<pre class="src src-c">  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">kernel/timer.c</span>
  asmlinkage <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">sys_getuid</span>(<span style="color: #98fb98;">void</span>)
  {
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Only we change this so SMP safe </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #00ffff;">return</span> current-&gt;uid;
  }

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">net/socket.c</span>
asmlinkage <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">sys_socketcall</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">call</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">__user</span> *<span style="color: #eedd82;">args</span>)
{
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">a</span>[6];
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">a0</span>,<span style="color: #eedd82;">a1</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">err</span>;
  <span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">...</span>
  <span style="color: #00ffff;">switch</span>(call)
  {
    <span style="color: #00ffff;">case</span> SYS_SOCKET:
      err = sys_socket(a0,a1,a[2]);
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> SYS_BIND:
      err = sys_bind(a0,(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sockaddr</span> <span style="color: #98fb98;">__user</span> *)a1, a[2]);
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> SYS_CONNECT:
      err = sys_connect(a0, (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sockaddr</span> <span style="color: #98fb98;">__user</span> *)a1, a[2]);
      <span style="color: #00ffff;">break</span>;

      <span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">...</span>
    <span style="color: #00ffff;">default</span>:
      err = -EINVAL;
      <span style="color: #00ffff;">break</span>;
  }
  <span style="color: #00ffff;">return</span> err;
}
</pre>
</div>

<p>
每个函数声明都有一个 <code>asmlinkage</code> 标识,不是标准C的语法. <code>asmlinkage</code>
是一个汇编宏,定义在 <code>&lt;linkage.h&gt;</code> .
</p>
</div>
</li>
<li><a id="sec-3-1-2" name="sec-3-1-2"></a>Dispatching and Parameter Passing<br  /><div class="outline-text-4" id="text-3-1-2">
<p>
System calls唯一的以一个数字来标识.所有的calls由一个中心代码处理,使用这个数字去调用特定函数通过查询一个静态表.参数传递也由这个中心代码处理,
所以代码传递的实现与system call是独立的.
</p>

<p>
从user转到kernel模式,参数的传递以汇编代码实现来适应特定的平台特性. 参数传递直接在寄存器中在所有平台上.更多一个寄存器需要来存储system call的数字被使用来之后查找到相应的处理函数.
</p>

<p>
IA-32为例, 指令 <code>int $0x80</code> 转到kernel模式, system call数字在寄存器
<code>eax</code> ,其他参数在 ebx, ecx, edx,esi,和edi.
</p>

<p>
<code>sys_call_table</code> 的表格维护一组指向处理函数的函数指针,并在所有平台上.因为这个表格由汇编代码生成,所有在平台见不一样.但理念是一样的,通过system
call的数字标识,kernel在表中找到相应位置的处理函数.比如ARM定义的如下表格:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">arch/arm/kernel/calls.S</span>
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">0 </span><span style="color: #ff7f24;">*/</span>         CALL(sys_restart_syscall)
                CALL(sys_exit)
                CALL(sys_fork_wrapper)
                CALL(sys_read)
                CALL(sys_write)
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">5 </span><span style="color: #ff7f24;">*/</span>         CALL(sys_open)
                CALL(sys_close)
                CALL(sys_ni_syscall)            <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">was sys_waitpid </span><span style="color: #ff7f24;">*/</span>
                CALL(sys_creat)
                CALL(sys_link)
<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">...</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-3-1-3" name="sec-3-1-3"></a>Return to User Mode<br  /><div class="outline-text-4" id="text-3-1-3">
<p>
返回负值表示错误,正值和0说明成功.程序和kernel都不是对纯数字操作,而是使用符号定值,它们被定义在 <code>include/asm-generic/errno-base.h</code> 和
<code>include/asm-generic/errno.h</code> . 错误码直到并包括511被用来作为普通的错误, kernel特定的值使用512以上的.
</p>

<p>
如下的错误码:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&lt;asm-generic/errno-base.h&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">EPERM</span> 1 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Operation not permitted </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ENOENT</span> 2 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">No such file or directory </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ESRCH</span> 3 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">No such process </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">EINTR</span> 4 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Interrupted system call </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">EIO</span> 5 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">I/O error </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ENXIO</span> 6 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">No such device or address </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">E2BIG</span> 7 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Argument list too long </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ENOEXEC</span> 8 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Exec format error </span><span style="color: #ff7f24;">*/</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&lt;asm-generic/errno.h&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">EDEADLK</span> 35 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Resource deadlock would occur </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ENAMETOOLONG</span> 36 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">File name too long </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ENOLCK</span> 37 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">No record locks available </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ENOSYS</span> 38 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Function not implemented </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>

<p>
在这里所有的码是正值,所以返回时在它们之前加负号.比如,返回 <code>-ENOPERM</code>
来表示-1.
</p>

<p>
Linux使用 <code>long</code> 类型发送结果从kernle到用户空间.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Access to Userspace</h3>
<div class="outline-text-3" id="text-3-2">
<p>
尽管kernel代码已经尽最大努力分离kernel和用户空间,但还是有情况,kernel代码需要访问用户应用的虚拟内存.当如下两种情况:
</p>
<ul class="org-ul">
<li>system call需要超过6个不同的参数,可以传入一个指向结构的指针.
</li>
<li>system call运行产生一大堆数据不能通过正常的返回机制返回给用户程序.这个数据需要交换到提前定义好的用户内存空间.
</li>
</ul>
<p>
借助于特殊函数 <code>copy_to_user</code> 和 <code>copy_from_user</code> 来处理这个问题.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">System Call Tracing</h3>
<div class="outline-text-3" id="text-3-3">
<p>
ptrace的system call是 <code>sys_ptrace</code> .架构独立部分在 <code>kernel/ptrace.c</code>.
架构相关部分的函数 <code>arch_ptrace</code> ,在 <code>arch/arch/kernel/ptrace.c</code> .基本代码流程如下:
</p>


<div class="figure">
<p><img src="./Files/sys-ptrace.jpeg" alt="sys-ptrace.jpeg" />
</p>
</div>

<p>
ptrace的system call由参数 <code>request</code> 所决定. 一开始必要的工作, 获取传入
PID的 <code>task_struct</code> 通过 <code>ptrace_get_task_struct</code> . 内部使用
<code>find_task_by_vpid</code> 来找出要求的 <code>task_struct</code>,并且防止追踪 <code>init</code> 进程.
</p>
</div>

<ul class="org-ul"><li><a id="sec-3-3-1" name="sec-3-3-1"></a>Starting Tracing<br  /><div class="outline-text-4" id="text-3-3-1">
<p>
进程task结构中包含一些ptrace特定的元素:
</p>
<div class="org-src-container">

<pre class="src src-c">&lt;sched.h&gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">task_struct</span> {
...
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> ptrace;
...
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ptrace_list/ptrace_children forms the list of my children</span>
<span style="color: #ff7f24;">   * that were stolen by a ptracer. </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> ptrace_children;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">ptrace_list</span>;
...
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">task_struct</span> *real_parent; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">real parent process (when being debugged) </span><span style="color: #ff7f24;">*/</span>
...
};
</pre>
</div>

<p>
如果 <code>PTRACE_ATTACH</code> 设置, <code>ptrace_attach</code> 在追踪进程和目标进程建议一条链路.当它完成:
</p>
<ul class="org-ul">
<li>目标进程的元素 <code>ptrace</code> 设置到 <code>PT_TRACED</code> .
</li>
<li>追踪进程成为目标进程的父进程.(真的父进程在 <code>real_parent</code>).
</li>
<li>被追踪进程被加入追踪的 <code>ptrace_children</code> list中通过 <code>ptrace_list</code>.
</li>
<li>STOP信号被发送往被追踪进程.
</li>
</ul>

<p>
如果不同于 <code>PTRACE_ATTACH</code> 的行为被要求, <code>ptrace_check_attach</code> 先检测追踪器是否附加到此进程上.然后由 <code>arch_ptrace</code> 进一步处理.
</p>

<p>
进一步追踪行为由signal处理代码进行.当信号被传递,kernel检查进程
<code>task_struct</code> 的 <code>ptrace</code> 是否被设置 <code>PT_TRACED</code> 标识,如果是, 进程的状态被设置为 <code>TASK_STOPPED</code> 来中断执行. <code>notify_parent</code> 使用 <code>CHLD</code> 信号来通知追踪进程.然后追踪进程进行对目标进程需要的检查.
</p>
</div>
</li></ul>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Stopping Tracing</h3>
<div class="outline-text-3" id="text-3-4">
<p>
追踪关闭使用 <code>PTRACE_DETACH</code> ,使得ptrace把任务交给在 <code>kernel/ptrace.c</code>
中的 <code>ptrace_detach</code> , 主要完成如下步骤:
</p>
<ol class="org-ol">
<li>架构相关的 <code>ptrace_disable</code> 做一些底层操作来停止追踪.
</li>
<li><code>TIF_SYSCALL_TRACE</code> 标识被从子进程中移除.
</li>
<li>进程 <code>task_struct</code> 的元素 <code>ptrace</code> 被重置为0, 目标进程从最终进程的
<code>ptrace_children</code> list中移除.
</li>
<li>父进程重置通过设置 <code>task_struct-&gt;parent</code> 为 <code>real_parent</code>.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">reference</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><code>ptrace_attach</code></h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ptrace_attach</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">task_struct</span> *<span style="color: #eedd82;">task</span>)
{
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">retval</span>;

        audit_ptrace(task);

        retval = -EPERM;
        <span style="color: #00ffff;">if</span> (unlikely(task-&gt;flags &amp; PF_KTHREAD))
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">out</span>;
        <span style="color: #00ffff;">if</span> (same_thread_group(task, current))
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">out</span>;

        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * Protect exec's credential calculations against our interference;</span>
<span style="color: #ff7f24;">         * interference; SUID, SGID and LSM creds get determined differently</span>
<span style="color: #ff7f24;">         * under ptrace.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        retval = -ERESTARTNOINTR;
        <span style="color: #00ffff;">if</span> (mutex_lock_interruptible(&amp;task-&gt;cred_guard_mutex))
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">out</span>;

        task_lock(task);
        retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH);
        task_unlock(task);
        <span style="color: #00ffff;">if</span> (retval)
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">unlock_creds</span>;

        write_lock_irq(&amp;tasklist_lock);
        retval = -EPERM;
        <span style="color: #00ffff;">if</span> (unlikely(task-&gt;exit_state))
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">unlock_tasklist</span>;
        <span style="color: #00ffff;">if</span> (task-&gt;ptrace)
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">unlock_tasklist</span>;

        task-&gt;ptrace = PT_PTRACED;
        <span style="color: #00ffff;">if</span> (capable(CAP_SYS_PTRACE))
                task-&gt;ptrace |= PT_PTRACE_CAP;

        __ptrace_link(task, current);
        send_sig_info(SIGSTOP, SEND_SIG_FORCED, task);

        retval = 0;
<span style="color: #7fffd4;">unlock_tasklist</span>:
        write_unlock_irq(&amp;tasklist_lock);
<span style="color: #7fffd4;">unlock_creds</span>:
        mutex_unlock(&amp;task-&gt;cred_guard_mutex);
<span style="color: #7fffd4;">out</span>:
        <span style="color: #00ffff;">return</span> retval;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><code>ptrace_detach</code></h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ptrace_detach</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">task_struct</span> *<span style="color: #eedd82;">child</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">data</span>)
{
        <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">dead</span> = <span style="color: #7fffd4;">false</span>;

        <span style="color: #00ffff;">if</span> (!valid_signal(data))
                <span style="color: #00ffff;">return</span> -EIO;

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Architecture-specific hardware disable .. </span><span style="color: #ff7f24;">*/</span>
        ptrace_disable(child);
        clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);

        write_lock_irq(&amp;tasklist_lock);
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * This child can be already killed. Make sure de_thread() or</span>
<span style="color: #ff7f24;">         * our sub-thread doing do_wait() didn't do release_task() yet.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span> (child-&gt;ptrace) {
                child-&gt;exit_code = data;
                dead = __ptrace_detach(current, child);
                <span style="color: #00ffff;">if</span> (!child-&gt;exit_state)
                        wake_up_process(child);
        }
        write_unlock_irq(&amp;tasklist_lock);

        <span style="color: #00ffff;">if</span> (unlikely(dead))
                release_task(child);

        <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2015-03-05 Thu 23:20</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
