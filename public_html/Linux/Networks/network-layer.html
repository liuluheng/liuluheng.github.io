<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Network layer</title>
<!-- 2014-11-19 Wed 20:20 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Network layer</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">IPv4</a>
<ul>
<li><a href="#sec-1-1">Receiving Packets</a></li>
<li><a href="#sec-1-2">Packet Forwarding</a></li>
<li><a href="#sec-1-3">Sending Packets</a></li>
<li><a href="#sec-1-4">Netfilter</a></li>
</ul>
</li>
<li><a href="#sec-2">IPv6</a>
<ul>
<li><a href="#sec-2-1">Overview and Innovations</a></li>
<li><a href="#sec-2-2">Implementation</a></li>
</ul>
</li>
<li><a href="#sec-3">reference</a>
<ul>
<li><a href="#sec-3-1"><code>ip_local_deliver</code></a></li>
<li><a href="#sec-3-2"><code>ip_defrag</code></a></li>
<li><a href="#sec-3-3"><code>inet_add_protocol</code></a></li>
<li><a href="#sec-3-4"><code>ip_route_input</code></a></li>
<li><a href="#sec-3-5"><code>ip_queue_xmit</code></a></li>
<li><a href="#sec-3-6"><code>nf_hook_slow</code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Network access layer仍然受传输媒介和适配器相关的驱动程序.Network
layer(特指IP协议)几乎脱离网络适配器的硬件属性.为什么是几乎? 因为,这一层不仅负责发送和接受数据,而且同时在不互相连接的系统中转发和路由包.找到最好的路由和选择合适的网络设备来发送包同样涉及处理底层地址(比如硬件特定MAC地址).
</p>

<p>
大包的fragmentation到小包不能进行如果不知道底层硬件特性.分包的大小由特定传输协议能力决定.
</p>

<p>
IP在1981年(RFC 791)定义,因为是很久远的产物.缺陷和不可预见的问题发生随着Internet的强力成长越来越明显.所以IPv6标准被发展出来取代如今的IPv4.
这里主要分析V4的算法实现,并稍微分析一下V6.IP协议细节了解:
</p>
<ul class="org-ul">
<li>W. Richard Stevens. Programmieren von UNIX- Netzwerken.
Hanser, 2000.
</li>
<li>W. Richard Stevens. TCP/ IP Illustrated I. The Protocols.
Addison-Wesley, 1994.
</li>
</ul>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">IPv4</h2>
<div class="outline-text-2" id="text-1">
<p>
IP包使用如下协议头:
</p>


<div class="figure">
<p><img src="./Files/ipv4-header.jpeg" alt="ipv4-header.jpeg" />
</p>
</div>

<ul class="org-ul">
<li>version指定IP协议版本.现在此值是4或6.
</li>
<li>IHL定于头的长度.因为不同的配置一般不同.
</li>
<li>Codepoint/Type of Service为更复杂的协议选项.
</li>
<li>Length指定 <b>总</b> 的包长.也就是,包括头和数据长度.
</li>
<li>fragment ID指定一个被分包的IP包的单个部分.分包程序赋值给原包的所有部分同一个fragment ID,以致她们能被识别为同一组的成员.相对位置由
fragment offset字段定义.
</li>
<li>3个状态bit(flag)打开或关闭特定特性:
<ol class="org-ol">
<li>DF 是 don't fragment的缩写,表明此包不能被分成小包.
</li>
<li>MF 表明当前的包是一个大包的分片,并且之后还有其他的分片.
</li>
<li>第3个域是"reserved for future use".
</li>
</ol>
</li>
<li>TTL是Time to LIVe的缩写,指定路由到接收端所经历的中间节点数.
</li>
<li>Protocol指定IP包中上层协议.比如TCP和UDP的唯一值.
</li>
<li>Checksum以header和data的内容计算而来.
</li>
<li>src和dest指定32-bit的source和destination的IP地址.
</li>
<li>options用来扩展IP的选项.
</li>
</ul>

<p>
所有在IP头中的数字值必须network byte order(big endian).
</p>

<p>
在kernel代码中头部由数据结构 <code>iphdr</code> 实现:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">include/linux/ip.h</span>
<span style="color: #b0c4de;">#if</span> <span style="color: #b0c4de;">defined</span>(__LITTLE_ENDIAN_BITFIELD)
        <span style="color: #98fb98;">__u8</span>    <span style="color: #eedd82;">ihl</span>:4,
                <span style="color: #eedd82;">version</span>:4;
<span style="color: #b0c4de;">#elif</span> <span style="color: #b0c4de;">defined</span> (__BIG_ENDIAN_BITFIELD)
        <span style="color: #98fb98;">__u8</span>    <span style="color: #eedd82;">version</span>:4,
                <span style="color: #eedd82;">ihl</span>:4;
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #98fb98;">__u8</span>    <span style="color: #eedd82;">tos</span>;
        <span style="color: #98fb98;">__be16</span>  <span style="color: #eedd82;">tot_len</span>;
        <span style="color: #98fb98;">__be16</span>  <span style="color: #eedd82;">id</span>;
        <span style="color: #98fb98;">__be16</span>  <span style="color: #eedd82;">frag_off</span>;
        <span style="color: #98fb98;">__u8</span>    <span style="color: #eedd82;">ttl</span>;
        <span style="color: #98fb98;">__u8</span>    <span style="color: #eedd82;">protocol</span>;
        <span style="color: #98fb98;">__sum16</span> <span style="color: #eedd82;">check</span>;
        <span style="color: #98fb98;">__be32</span>  <span style="color: #eedd82;">saddr</span>;
        <span style="color: #98fb98;">__be32</span>  <span style="color: #eedd82;">daddr</span>;
        <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">The options start here. </span><span style="color: #ff7f24;">*/</span>
};
</pre>
</div>

<p>
<code>ip_rcv</code> 函数是进入network layer的入口点.在kernel中,一个包的路由图如下:
<a id="ipv4-layer" name="ipv4-layer"></a>
<img src="./Files/route-ipv4-layer.jpeg" alt="route-ipv4-layer.jpeg" />
</p>

<p>
发送和接收操作并不总是分开,会交织在一起如果包只是通过电脑转发.
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Receiving Packets</h3>
<div class="outline-text-3" id="text-1-1">
<p>
当包到达 <code>ip_rcv</code> 后,一些信息会检查确保它是正确的.之后,kernel并不立刻继续处理包,而是允许netfilter hook被调用,来让数据包在userpace被处理.Netfiler hook是被在kernel代码中某些点插入的hook来是的动态的处理包.
</p>

<p>
当到达hook,注册此hook的处理在userspace被调用.Kernel端然后继续处理这个包.之后,收到的IP包到达交叉路口,需要决定包是发送往本顶系统还是远程电脑.
</p>

<p>
<code>ip_route_inpu</code> 负责选择路由.相对复杂的这个决定在之后分析. 之后进行的函数是 <code>ip_local_deliver</code> 和 <code>ip_forward</code> .
</p>
</div>
<ul class="org-ul"><li><a id="sec-1-1-1" name="sec-1-1-1"></a>Local Delivery to the Transport Layer<br  /><div class="outline-text-4" id="text-1-1-1">
<p>
当包发往本地电脑, <code>ip_local_deliver</code> 必须找到合适的transport layer 函数来处理.IP包通常使用TCP或UDP作为 transport layer.
</p>
</div>
</li>
<li><a id="sec-1-1-2" name="sec-1-1-2"></a>Defragmentation<br  /><div class="outline-text-4" id="text-1-1-2">
<p>
因为IP包是可以被分包的,使得不能马上确认一个完整的包收到.因此第一个任务是使用函数 <code>ip_defrag</code> 组装一个被分片的包.相应的代码流程如下:
</p>


<div class="figure">
<p><img src="./Files/ip-defrag.jpeg" alt="ip-defrag.jpeg" />
</p>
</div>

<p>
kernel在一个独立的cache中管理原本大包的分片,这个cache被成为 <i>fragment
cache</i> . 比如 <code>net-&gt;ipv4.frags(ip_fragment.c)</code> . 在此cache中,属于一起的分片在独立的一个等待队列中知道所有分片齐全.
</p>

<p>
<code>ip_find</code> 被调用去寻找分片等待队列.它使用一个涉及fragment ID,起始和目的地址,和包协议标示的hashing来确认这个包的等待队列是否已存在.如果没有,
一个新的队列创建并把此包放在里面. 通过 <code>ip_frag_queue</code> 能把包放如队列.
</p>

<p>
<code>ip_frag_queue</code> 放如新包后,并检查包的所有分片是否都在cache中,调用
<code>ip_frag_reasm</code> 来组装分片.
</p>

<p>
如果包的所有分片没有都到达, <code>ip_defrag</code> 返回一个非空的错误值来结束IP层包的处理.但所有分包都达到时继续处理.
</p>
</div>
</li>
<li><a id="sec-1-1-3" name="sec-1-1-3"></a>Delivery to the Transport Layer<br  /><div class="outline-text-4" id="text-1-1-3">
<p>
<code>ip_local_deliver</code> 处理完分包后,调用hook函数后继续调用
<code>ip_local_deliver_finish</code> .
</p>

<p>
包被传递到transport layer函数前需要确定协议是啥来调用相应协议的处理函数.所有基于IP层的协议都有一个 <code>net_protocol</code> 数据结构的实例:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_protocol</span> {
        <span style="color: #98fb98;">int</span>                     (*<span style="color: #87cefa;">handler</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>);
        <span style="color: #98fb98;">void</span>                    (*<span style="color: #87cefa;">err_handler</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>, <span style="color: #98fb98;">u32</span> <span style="color: #eedd82;">info</span>);
..
};
</pre>
</div>
<ul class="org-ul">
<li><code>handler</code> 是被传递包的协议处理函数.
</li>
<li><code>err_handler</code> 被调用当收到ICMP error信息时并需要传递到上层.
</li>
</ul>

<p>
在函数 <code>inet_add_protocol</code> 中,通过hash方法把各个协议映射到数组
<code>inet_protos</code> 中的单一条目下.
</p>

<p>
找到相应的协议 <code>inet_protocol</code> ,并调用其中处理函数 <code>handler</code>.至此包从
IP层被传送到更高层处理.比如 <code>tcp_v4_rcv</code> 函数接收TCP包, <code>udp_rcv</code> 接收
UDP包.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Packet Forwarding</h3>
<div class="outline-text-3" id="text-1-2">
<p>
IP 包可以如上传递到本地,或它们离开IP层转发到其他电脑,不再与本地上层协议交互. 有2类包的目的:
</p>
<ol class="org-ol">
<li>目的电脑与这发送电脑在同一个本地网络.
</li>
<li>远程电脑不在本地网络,只能通过网管通信.
</li>
</ol>

<p>
第二种情况相对复杂.转发包路由途中将发往的第一个站点必须找到以致离最终目的进一步.所以不单单需要电脑所处的网络结构信息,还需要相邻的网络和附加的出口路径结构信息.
</p>

<p>
这些信息由kernel维护的 <i>路由表(routing tables)</i> 提供.函数
<code>ip_route_input</code> 被调用当一个包以路由的形式收到,不仅仅它被识别为本地传递或转发,并且找到去目的的路由.目的存储在socket buffer的字段 <code>dst</code> 中.
</p>

<p>
转发函数 <code>ip_forward</code> 如下:
</p>


<div class="figure">
<p><img src="./Files/ip-forward.jpeg" alt="ip-forward.jpeg" />
</p>
</div>

<p>
先检查TTL值允许被传递到下一个hop. 若可以, <code>ip_decrease_ttl</code> 把TTL减1并更新包的checksum.
</p>

<p>
一旦 <code>NF_INET_FORWARD</code> 被调用完,kernel继续在 <code>ip_forward_finish</code> 中处理,这个函数跳转到另外2个函数:
</p>
<ol class="org-ol">
<li>如果包包含其他的参数(一般不会这种情况),它们被 <code>ip_forward_options</code>
   处理.
</li>
<li><code>dst_output</code> 把包交给路由发送函数,这个函数在 <code>skb-&gt;dst-&gt;output</code> 中.
一般 <code>ip_output</code> 用作此目的, 把包发送到与目的相符的网络适配器.
<code>ip_output</code> 是IP层的发送操作,下一节分析.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Sending Packets</h3>
<div class="outline-text-3" id="text-1-3">
<p>
kernel提供很多个函数来让上层协议发送数据通过IP层. <code>ip_queue_xmit</code> 是其中用的相对多的函数,流程如下:
</p>


<div class="figure">
<p><img src="./Files/ip-queue-xmit.jpeg" alt="ip-queue-xmit.jpeg" />
</p>
</div>

<p>
首要是为这个包找寻发送路由.kernel利用这样的事实,来自同一个socket的所有包有相同的目的地址,所以路由不需要每次都决定, 之后会分析的 <code>(struct
dst_entry *)skb-&gt;_skb_dst</code> 结构指向相应的路由信息.
</p>

<p>
一旦 <code>ip_send_check</code> 为这个包生成checksum后,kernel调用 <code>ip_local_out</code>,
并调用netfilter hook <code>NF_INET_LOCAL_OUT</code>. 最后 <code>dst_output</code> 被调用. ,
这个函数在 <code>skb-&gt;dst-&gt;output</code> 中.一般 <code>ip_output</code> 用作此目的, 把包发送到与目的相符的网络适配器.
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-3-1" name="sec-1-3-1"></a>Transition to the Network Access Layer<br  /><div class="outline-text-4" id="text-1-3-1">
<p>
<code>ip_output</code> 的流程如下, 根据包是否需要分片,函数被分成两部分处理:
<img src="./Files/ip-output.jpeg" alt="ip-output.jpeg" />
</p>

<p>
首先netfilter hook <code>NF_INET_POST_ROUTING</code> 被调用,紧接着
<code>ip_finish_output</code>.通过查看传送介质的MTU决定是否需要分片.如果不需要直接调用 <code>ip_finish_output2</code>. 这个函数查看socket buffer是否有足够空间给硬件头.必要的话,调用 <code>skb_realloc_headroom</code> 添加额外的空间.为了完成传送到network access layer, 由路由层设置的 <code>dst-&gt;neighbour-&gt;output</code> 函数被调用, 通常是函数 <code>dev_queue_xmit</code>.
</p>
</div>
</li>

<li><a id="sec-1-3-2" name="sec-1-3-2"></a>Packet Fragmenting<br  /><div class="outline-text-4" id="text-1-3-2">
<p>
IP包被分成小包通过函数 <code>ip_fragment</code>, 如下图:
</p>


<div class="figure">
<p><img src="./Files/fragmenting-ip-packet.jpeg" alt="fragmenting-ip-packet.jpeg" />
</p>
</div>

<p>
忽略RFC791文档中一些微妙的条款,IP 分片比较直观的.在循环的每次,与相应
MTU相容大小的分片从包中提取出来.一个新的IP头稍微改变的socket buffer被创建来放提取的数据分片.并做如下修改:
</p>
<ul class="org-ul">
<li>共同的fragment ID被分配给所有分片来支持在目的系统组装.
</li>
<li>fragment的序列里fragment offset为基础计算设置.
</li>
<li>more fragments位设置.只有最后分片设置为0.
</li>
</ul>

<p>
每个分片在通过 <code>ip_send_check</code> 生成checksum后调用 <code>ip_output</code> 来发送.
</p>
</div>
</li>

<li><a id="sec-1-3-3" name="sec-1-3-3"></a>Routing<br  /><div class="outline-text-4" id="text-1-3-3">
<p>
Routing是IP实现中很重要的一部分,不仅仅转发外部包需要,传递本地生成的数据同样需要.找寻正确的传送路径问题不仅是非本地地址所引起,更是许多个网络接口的存在.当只有一个物理网络适配器是,这种情况同样存在,因为可以有虚拟接口如loopback设备.
</p>

<p>
每个收到的包属于如下3中类别:
</p>
<ol class="org-ol">
<li>发给本地host.
</li>
<li>发给直接与现在host相连的设备.
</li>
<li>发给要通过中间系统达到的远端设备.
</li>
</ol>

<p>
之前分析的是第一类,包被传送到更高层协议处理.如果包的目的系统直接与本地主机相连,路由基本找到此相应的网络卡.否则要参考路由信息找寻包能发送的网关系统.
</p>

<p>
Cache和hash表被使用来加速运行,因为许多路由任务是时间关键的.这里不具体分析在kernel找寻正确路由的机制.仅仅查看kernel被用来做路由结果的数据结构.
</p>

<p>
路由的起始点是 <code>ip_route_input</code> 函数,它先在路由cache中找寻路由.
</p>

<p>
如没有找到, <code>ip_route_input_slow</code> 被调用来建立新的路由.基本上,这个函数依赖 <code>fib_lookup</code> ,它的返回值是 <code>fib_result</code> 结构含有需要信息的实例.fib是
 <i>forwarding information base</i> 的缩写,是一个管理路由信息的表.
</p>

<p>
路由结果与socket buffer相关联是通过它的dst元素指向 <code>dest_entry</code> 结构的实例.这个实例是当lookup时被填充.这个数据结构的部分定义:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">include/net/dst.h</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dst_entry</span>
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">dev</span>;
  <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">input</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span>*);
  <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">output</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span>*);
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">neighbour</span> *<span style="color: #eedd82;">neighbour</span>;
};
</pre>
</div>

<ul class="org-ul">
<li>input 和 output被调用来处理入口和出口的包.
</li>
<li>dev 指定来处理包的网络设备.
</li>
</ul>

<p>
input和output被赋予不同的函数依赖于包的类型.
</p>
<ul class="org-ul">
<li>本地传递时,input设置为 <code>ip_local_deliver</code> ,而output是
<code>ip_rt_bug</code> .(后者函数只是打印error信息给kernel logs,因为对本地包调用output是不应该发生的错误情况).
</li>
<li>转发时,input设置为 <code>ip_forward</code> ,而output是 <code>ip_output</code> .
</li>
</ul>

<p>
<code>neighbour</code> 元素保存本地网络设备的IP和硬件地址,这些信息直接由network
access层获取.它部分结构如下:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">include/net/neighbour.h</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">neighbour</span>
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">dev</span>;
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">ha</span>[ALIGN(<span style="color: #98fb98;">MAX_ADDR_LEN</span>, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>))];
  <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">output</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>);
};
</pre>
</div>
<ul class="org-ul">
<li>ha是设备的硬件地址.
</li>
<li>output指向通过网络适配器传送包需调用的函数.
</li>
</ul>

<p>
neighbour实例是有ARP层创建的,实现 <i>address resolution protocol</i> &#x2014;把
IP地址转换成硬件地址.因为 <code>dst_entry</code> 结构有一个指向neighbour实例的指针,network access层的代码可以调用output函数当包离开系统发往网络适配器.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Netfilter</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Netfilter是Linux kernel提供根据动态定义规则来过滤和处理包的框架.
</p>
</div>
<ul class="org-ul"><li><a id="sec-1-4-1" name="sec-1-4-1"></a>Extending Network Functionality<br  /><div class="outline-text-4" id="text-1-4-1">
<p>
Netfilter框架为kernel添加如下能力:
</p>
<ul class="org-ul">
<li>Packet filtering对于不同流的方向(进入,出去,转发)依赖于状态等要求.
</li>
<li>Network address translation(NAT) 根据一定规则转换接收和目的地址.
</li>
<li>Packet mangling和manipulation 根据特定规则分片和改变包.
</li>
</ul>

<p>
Netfilter hooks位于kernel的不同点来支持执行它的代码.如<a href="#ipv4-layer">上图</a>,这里只分析
IPv4,但概念可以同样应用到IPv6和DECNET协议.
</p>

<p>
Netfilter实现可以分为2部分:
</p>
<ul class="org-ul">
<li>Hooks在kernel代码中,并使用来调用netfilter代码,并位于网络实现的中心地带.
</li>
<li>Netfilter 模块代码被hooks中调用,但独立于其他的网络代码.
</li>
</ul>

<p>
Iptables 被管理者使用来配置防火墙,包过滤和类似的功能,它简单的基于
netfilter 框架的模块,提供综合,定义好一组库函数来方便包处理.
</p>
</div>
</li>
<li><a id="sec-1-4-2" name="sec-1-4-2"></a>Calling Hook Functions<br  /><div class="outline-text-4" id="text-1-4-2">
<p>
Hooks的一个重要特性是它们把一个函数分为2部分&#x2013;第一部分在netfilter代码之前那运行,另一部分在之后.为什么使用2个函数而不是使用一个特定的
netfilter函数来执行所有相关netfilter模块,并返回到调用函数呢?这个方法初看有点复杂,但有它的益处.它使得能决定不把netfilter功能编译进kernel,这样网络函数能损失速度的执行.它也使得不用在网络实现代码中添加对于netfilter
打开或关闭的预处理,来选择合适的代码编译.
</p>

<p>
Netfilter hooks通过来自 <code>&lt;netfilter.h&gt;</code> 的 <code>NF_HOOK</code> 宏的调用.如果
netfilter支持打开,宏的定义如下:
</p>
<div class="org-src-container">

<pre class="src src-c">  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&lt;netfilter.h&gt;</span>
  <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">nf_hook_thresh</span>(<span style="color: #98fb98;">u_int8_t</span> <span style="color: #eedd82;">pf</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">hook</span>,
                                   <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>,
                                   <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">indev</span>,
                                   <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">outdev</span>,
                                   <span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">okfn</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *), <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thresh</span>,
                                   <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cond</span>)
  {
        <span style="color: #00ffff;">if</span> (!cond)
          <span style="color: #00ffff;">return</span> 1;
        <span style="color: #00ffff;">return</span> nf_hook_slow(pf, hook, skb, indev, outdev, okfn, thresh);
  }

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">NF_HOOK_THRESH</span>(<span style="color: #eedd82;">pf</span>, <span style="color: #eedd82;">hook</span>, <span style="color: #eedd82;">skb</span>, <span style="color: #eedd82;">indev</span>, <span style="color: #eedd82;">outdev</span>, <span style="color: #eedd82;">okfn</span>, <span style="color: #eedd82;">thresh</span>)      \
({<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">__ret</span>;                                                                   \
<span style="color: #00ffff;">if</span> ((__ret=nf_hook_thresh(pf, hook, (skb), indev, outdev, okfn, thresh, 1)) == 1)\
        __ret = (okfn)(skb);                                                   \
__ret;})

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">NF_HOOK</span>(<span style="color: #eedd82;">pf</span>, <span style="color: #eedd82;">hook</span>, <span style="color: #eedd82;">skb</span>, <span style="color: #eedd82;">indev</span>, <span style="color: #eedd82;">outdev</span>, <span style="color: #eedd82;">okfn</span>) \
        NF_HOOK_THRESH(pf, hook, skb, indev, outdev, okfn, INT_MIN)
</pre>
</div>

<p>
红的参数有如下意义:
</p>
<ul class="org-ul">
<li><code>pf</code> 指调用哪个netfilter hook的协议类.IPv4层的所有调用使用 <code>PF_INET</code>
  .
</li>
<li><code>hook</code> 指hook号.部分值定义在 <code>&lt;netfilter_ipv4.h&gt;</code> .在IPv4中,类似名字
<code>NF_IP_FORWARD</code> , <code>NF_IP_LOCAL_OUT</code> 等.
</li>
<li><code>skb</code> 要被处理的socket buffer.
</li>
<li><code>indev</code> 和 <code>outdev</code> 指向包进入和离开kernel的网络设备的 <code>net_device</code>
  实例. Null指针可以赋值给它们.
</li>
<li><code>okfn</code> 指向函数 <code>int (*okfn)(struct sk_buff *)</code> 的指针.当netfilter
hook执行完后执行它.
</li>
</ul>

<p>
宏展开到 <code>nf_hook_thresh</code> 前,先到 <code>NF_HOOK_THRESH</code> ,提供只有高于一定级别的netfilter hooks才被调用的功能. <code>NF_HOOK</code> 中,threadhold被设置为最下值,所以所有hook函数都将被调用.
</p>

<p>
分析一下 <code>NF_HOOK_THRESH</code> 的实现. 
</p>
<ol class="org-ol">
<li><code>nf_hook_thresh</code> 被调用.
</li>
<li>这个函数检查 <code>cond</code> 是否真, 若不是直接返回1.
</li>
<li>否则 <code>nf_hook_slow</code> 被调用,这个函数遍历所有注册的netfilter hooks 并调用它们.如果包被接受,返回1,否则其他值.
</li>
<li>如果 <code>nf_hook_thresh</code> 返回1, netfilter裁定接受包,之后继续 <code>okfn</code> 指向的函数.
</li>
</ol>
</div>
</li>
<li><a id="sec-1-4-3" name="sec-1-4-3"></a>Scanning the Hook Table<br  /><div class="outline-text-4" id="text-1-4-3">
<p>
<code>nf_hook_slow</code> 被调用,如果至少有一个hook函数被注册并需要被调用.所有
hooks存储在 <code>nf_hook</code> 的二维数组中:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">net/netfilter/core.c</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">nf_hooks</span>[NPROTO][NF_MAX_HOOKS] __read_mostly;
</pre>
</div>

<p>
<code>NPROTO</code> 指定系统支持的协议类的最大数.每个类的符号定值如 <code>PF_INET</code> 和
<code>PF_DECnet</code>,在 <code>include/linux/socket.h</code> 中. 每个协议最大hooks数是
<code>NF_MAX_HOOKS</code>.
</p>

<p>
链表元素是 <code>nf_hook_ops</code> 如下:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nf_hook_ops</span>
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">list</span>;

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">User fills in from here down. </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">nf_hookfn</span> *<span style="color: #eedd82;">hook</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">module</span> *<span style="color: #eedd82;">owner</span>;
        <span style="color: #98fb98;">u_int8_t</span> <span style="color: #eedd82;">pf</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">hooknum</span>;
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Hooks are ordered in ascending priority. </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">priority</span>;
};
</pre>
</div>

<p>
除了list和owner之外,其他元素的意义:
</p>
<ul class="org-ul">
<li><code>hook</code> 指向hook函数的指针,与 <code>NF_HOOK</code> 宏相同的参数:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&lt;netfilter.h&gt;</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #98fb98;">nf_hookfn</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">hooknum</span>,
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> **<span style="color: #eedd82;">skb</span>,
<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">in</span>,
<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">out</span>,
<span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">okfn</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *));
</pre>
</div>
</li>
<li><code>pf</code> 和 <code>hooknum</code> 指向相应hook的协议类和hook号.
</li>
<li>在list中,hooks按照级别( <code>priority</code> )的升序排序.
</li>
</ul>

<p>
适当的list通过协议类和hook号从 <code>nf_hook</code> 数组中获取,然后 <code>nf_iterate</code>
遍历list中元素,并调用hook函数.
</p>
</div>
</li>
<li><a id="sec-1-4-4" name="sec-1-4-4"></a>Activating the Hook Functions<br  /><div class="outline-text-4" id="text-1-4-4">
<p>
每个hook函数可能返回的值如下:
</p>
<ul class="org-ul">
<li><code>NF_ACCEPT</code> 接受一个包. 没有对数据做什么改变,kernel继续使用为修改的包做上层的操作.
</li>
<li><code>NF_STOLEN</code> 指代hook函数stolen这个包并处理它.所以这个包不再被kernel
所处理,进一步其他协议层的处理被丢弃.
</li>
<li><code>NF_DROP</code> 告诉kernel丢弃此包.
</li>
<li><code>NF_QUEUE</code> 把包放到一个等待队列,让用户空间的代码去处理它.
</li>
<li><code>NF_REPEAT</code> 再次调用此hook.
</li>
</ul>

<p>
Linux kernel提供一些hook函数,具体见<a href="http://wiki.dreamrunner.org/public_html/Linux/Networks/netfilter.html">Linux Netfilter</a>.
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">IPv6</h2>
<div class="outline-text-2" id="text-2">
<p>
IPv4有32位的地址,支持最多 2<sup>32</sup> 个不同地址主机,随着接入网络的设备暴增,
地址不够用.使用新的IPv6.
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Overview and Innovations</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在1998,命名IPv6的新标准被定义.所有此协议的实现位于 <code>net/ipv6</code> 目录.大部分IPv6的概念与IPv4类似,简单的分析下它.
</p>

<p>
IPv6的关键改变是一个使用128字节IP地址的全新包格式.IPv6的结构如下图:
</p>


<div class="figure">
<p><img src="./Files/ipv6-structure.jpeg" alt="ipv6-structure.jpeg" />
</p>
</div>

<p>
相比IPv4,这个结构相对简单. 只有8个头部区域,而不是14个.
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Implementation</h3>
<div class="outline-text-3" id="text-2-2">
<p>
IPv6的代码流程如下图,与IPv4类似:
</p>


<div class="figure">
<p><img src="./Files/flow-ipv6.jpeg" alt="flow-ipv6.jpeg" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">reference</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><code>ip_local_deliver</code></h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ip_local_deliver</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
{
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         *      Reassemble IP fragments.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>

        <span style="color: #00ffff;">if</span> (ip_hdr(skb)-&gt;frag_off &amp; htons(IP_MF | IP_OFFSET)) {
                <span style="color: #00ffff;">if</span> (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))
                        <span style="color: #00ffff;">return</span> 0;
        }

        <span style="color: #00ffff;">return</span> NF_HOOK(PF_INET, NF_INET_LOCAL_IN, skb, skb-&gt;dev, <span style="color: #7fffd4;">NULL</span>,
                       ip_local_deliver_finish);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><code>ip_defrag</code></h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ip_defrag</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>, <span style="color: #98fb98;">u32</span> <span style="color: #eedd82;">user</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">ipq</span> *<span style="color: #eedd82;">qp</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net</span> *<span style="color: #eedd82;">net</span>;

        net = skb-&gt;dev ? dev_net(skb-&gt;dev) : dev_net(skb_dst(skb)-&gt;dev);
        IP_INC_STATS_BH(net, IPSTATS_MIB_REASMREQDS);

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Start by cleaning up the memory. </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span> (atomic_read(&amp;net-&gt;ipv4.frags.mem) &gt; net-&gt;ipv4.frags.high_thresh)
                ip_evictor(net);

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Lookup (or create) queue header </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span> ((qp = ip_find(net, ip_hdr(skb), user)) != <span style="color: #7fffd4;">NULL</span>) {
                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ret</span>;

                spin_lock(&amp;qp-&gt;q.lock);

                ret = ip_frag_queue(qp, skb);

                spin_unlock(&amp;qp-&gt;q.lock);
                ipq_put(qp);
                <span style="color: #00ffff;">return</span> ret;
        }

        IP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);
        kfree_skb(skb);
        <span style="color: #00ffff;">return</span> -ENOMEM;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><code>inet_add_protocol</code></h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">inet_add_protocol</span>(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_protocol</span> *<span style="color: #eedd82;">prot</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">protocol</span>)
{
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">hash</span>, <span style="color: #eedd82;">ret</span>;

        hash = protocol &amp; (MAX_INET_PROTOS - 1);

        spin_lock_bh(&amp;inet_proto_lock);
        <span style="color: #00ffff;">if</span> (inet_protos[hash]) {
                ret = -1;
        } <span style="color: #00ffff;">else</span> {
                inet_protos[hash] = prot;
                ret = 0;
        }
        spin_unlock_bh(&amp;inet_proto_lock);

        <span style="color: #00ffff;">return</span> ret;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><code>ip_route_input</code></h3>
<div class="outline-text-3" id="text-3-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ip_route_input</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>, <span style="color: #98fb98;">__be32</span> <span style="color: #eedd82;">daddr</span>, <span style="color: #98fb98;">__be32</span> <span style="color: #eedd82;">saddr</span>,
                   <span style="color: #98fb98;">u8</span> <span style="color: #eedd82;">tos</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">dev</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rtable</span> * <span style="color: #eedd82;">rth</span>;
        <span style="color: #98fb98;">unsigned</span>        <span style="color: #eedd82;">hash</span>;
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">iif</span> = dev-&gt;ifindex;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net</span> *<span style="color: #eedd82;">net</span>;

        net = dev_net(dev);

        <span style="color: #00ffff;">if</span> (!rt_caching(net))
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">skip_cache</span>;

        tos &amp;= IPTOS_RT_MASK;
        hash = rt_hash(daddr, saddr, iif, rt_genid(net));

        rcu_read_lock();
        <span style="color: #00ffff;">for</span> (rth = rcu_dereference(rt_hash_table[hash].chain); rth;
             rth = rcu_dereference(rth-&gt;u.dst.rt_next)) {
                <span style="color: #00ffff;">if</span> (((rth-&gt;fl.fl4_dst ^ daddr) |
                     (rth-&gt;fl.fl4_src ^ saddr) |
                     (rth-&gt;fl.iif ^ iif) |
                     rth-&gt;fl.oif |
                     (rth-&gt;fl.fl4_tos ^ tos)) == 0 &amp;&amp;
                    rth-&gt;fl.mark == skb-&gt;mark &amp;&amp;
                    net_eq(dev_net(rth-&gt;u.dst.dev), net) &amp;&amp;
                    !rt_is_expired(rth)) {
                        dst_use(&amp;rth-&gt;u.dst, jiffies);
                        RT_CACHE_STAT_INC(in_hit);
                        rcu_read_unlock();
                        skb_dst_set(skb, &amp;rth-&gt;u.dst);
                        <span style="color: #00ffff;">return</span> 0;
                }
                RT_CACHE_STAT_INC(in_hlist_search);
        }
        rcu_read_unlock();

<span style="color: #7fffd4;">skip_cache</span>:
        <span style="color: #00ffff;">if</span> (ipv4_is_multicast(daddr)) {
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">in_device</span> *<span style="color: #eedd82;">in_dev</span>;

                rcu_read_lock();
                <span style="color: #00ffff;">if</span> ((in_dev = __in_dev_get_rcu(dev)) != <span style="color: #7fffd4;">NULL</span>) {
                        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">our</span> = ip_check_mc(in_dev, daddr, saddr,
                                ip_hdr(skb)-&gt;protocol);
                        <span style="color: #00ffff;">if</span> (our
<span style="color: #b0c4de;">#ifdef</span> CONFIG_IP_MROUTE
                            || (!ipv4_is_local_multicast(daddr) &amp;&amp;
                                IN_DEV_MFORWARD(in_dev))
<span style="color: #b0c4de;">#endif</span>
                            ) {
                                rcu_read_unlock();
                                <span style="color: #00ffff;">return</span> ip_route_input_mc(skb, daddr, saddr,
                                                         tos, dev, our);
                        }
                }
                rcu_read_unlock();
                <span style="color: #00ffff;">return</span> -EINVAL;
        }
        <span style="color: #00ffff;">return</span> ip_route_input_slow(skb, daddr, saddr, tos, dev);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><code>ip_queue_xmit</code></h3>
<div class="outline-text-3" id="text-3-5">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ip_queue_xmit</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ipfragok</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sock</span> *<span style="color: #eedd82;">sk</span> = skb-&gt;sk;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inet_sock</span> *<span style="color: #eedd82;">inet</span> = inet_sk(sk);
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">ip_options</span> *<span style="color: #eedd82;">opt</span> = inet-&gt;opt;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rtable</span> *<span style="color: #eedd82;">rt</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">iphdr</span> *<span style="color: #eedd82;">iph</span>;
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Skip all of this if the packet is already routed,</span>
<span style="color: #ff7f24;">         * f.e. by something like SCTP.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        rt = skb_rtable(skb);
        <span style="color: #00ffff;">if</span> (rt != <span style="color: #7fffd4;">NULL</span>)
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">packet_routed</span>;

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Make sure we can route this packet. </span><span style="color: #ff7f24;">*/</span>
        rt = (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rtable</span> *)__sk_dst_check(sk, 0);
        <span style="color: #00ffff;">if</span> (rt == <span style="color: #7fffd4;">NULL</span>) {
                <span style="color: #98fb98;">__be32</span> <span style="color: #eedd82;">daddr</span>;

                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Use correct destination address if we have options. </span><span style="color: #ff7f24;">*/</span>
                daddr = inet-&gt;daddr;
                <span style="color: #00ffff;">if</span>(opt &amp;&amp; opt-&gt;srr)
                        daddr = opt-&gt;faddr;

                {
                        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">flowi</span> <span style="color: #eedd82;">fl</span> = { .oif = sk-&gt;sk_bound_dev_if,
                                            .mark = sk-&gt;sk_mark,
                                            .nl_u = { .ip4_u =
                                                      { .daddr = daddr,
                                                        .saddr = inet-&gt;saddr,
                                                        .tos = RT_CONN_FLAGS(sk) } },
                                            .proto = sk-&gt;sk_protocol,
                                            .flags = inet_sk_flowi_flags(sk),
                                            .uli_u = { .ports =
                                                       { .sport = inet-&gt;sport,
                                                         .dport = inet-&gt;dport } } };

                        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">If this fails, retransmit mechanism of transport layer will</span>
<span style="color: #ff7f24;">                         * keep trying until route appears or the connection times</span>
<span style="color: #ff7f24;">                         * itself out.</span>
<span style="color: #ff7f24;">                         </span><span style="color: #ff7f24;">*/</span>
                        security_sk_classify_flow(sk, &amp;fl);
                        <span style="color: #00ffff;">if</span> (ip_route_output_flow(sock_net(sk), &amp;rt, &amp;fl, sk, 0))
                                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">no_route</span>;
                }
                sk_setup_caps(sk, &amp;rt-&gt;u.dst);
        }
        skb_dst_set(skb, dst_clone(&amp;rt-&gt;u.dst));

<span style="color: #7fffd4;">packet_routed</span>:
        <span style="color: #00ffff;">if</span> (opt &amp;&amp; opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_dst != rt-&gt;rt_gateway)
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">no_route</span>;

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">OK, we know where to send it, allocate and build IP header. </span><span style="color: #ff7f24;">*/</span>
        skb_push(skb, <span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">iphdr</span>) + (opt ? opt-&gt;optlen : 0));
        skb_reset_network_header(skb);
        iph = ip_hdr(skb);
        *((<span style="color: #98fb98;">__be16</span> *)iph) = htons((4 &lt;&lt; 12) | (5 &lt;&lt; 8) | (inet-&gt;tos &amp; 0xff));
        <span style="color: #00ffff;">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;u.dst) &amp;&amp; !ipfragok)
                iph-&gt;frag_off = htons(IP_DF);
        <span style="color: #00ffff;">else</span>
                iph-&gt;frag_off = 0;
        iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;u.dst);
        iph-&gt;protocol = sk-&gt;sk_protocol;
        iph-&gt;saddr    = rt-&gt;rt_src;
        iph-&gt;daddr    = rt-&gt;rt_dst;
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Transport layer set skb-&gt;h.foo itself. </span><span style="color: #ff7f24;">*/</span>

        <span style="color: #00ffff;">if</span> (opt &amp;&amp; opt-&gt;optlen) {
                iph-&gt;ihl += opt-&gt;optlen &gt;&gt; 2;
                ip_options_build(skb, opt, inet-&gt;daddr, rt, 0);
        }

        ip_select_ident_more(iph, &amp;rt-&gt;u.dst, sk,
                             (skb_shinfo(skb)-&gt;gso_segs ?: 1) - 1);

        skb-&gt;priority = sk-&gt;sk_priority;
        skb-&gt;mark = sk-&gt;sk_mark;

        <span style="color: #00ffff;">return</span> ip_local_out(skb);

<span style="color: #7fffd4;">no_route</span>:
        IP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);
        kfree_skb(skb);
        <span style="color: #00ffff;">return</span> -EHOSTUNREACH;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><code>nf_hook_slow</code></h3>
<div class="outline-text-3" id="text-3-6">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">nf_hook_slow</span>(<span style="color: #98fb98;">u_int8_t</span> <span style="color: #eedd82;">pf</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">hook</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>,
                 <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">indev</span>,
                 <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">outdev</span>,
                 <span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">okfn</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *),
                 <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">hook_thresh</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> *<span style="color: #eedd82;">elem</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">verdict</span>;
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ret</span> = 0;

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">We may already have this, but read-locks nest anyway </span><span style="color: #ff7f24;">*/</span>
        rcu_read_lock();

        elem = &amp;nf_hooks[pf][hook];
<span style="color: #7fffd4;">next_hook</span>:
        verdict = nf_iterate(&amp;nf_hooks[pf][hook], skb, hook, indev,
                             outdev, &amp;elem, okfn, hook_thresh);
        <span style="color: #00ffff;">if</span> (verdict == NF_ACCEPT || verdict == NF_STOP) {
                ret = 1;
        } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (verdict == NF_DROP) {
                kfree_skb(skb);
                ret = -EPERM;
        } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> ((verdict &amp; NF_VERDICT_MASK) == NF_QUEUE) {
                <span style="color: #00ffff;">if</span> (!nf_queue(skb, elem, pf, hook, indev, outdev, okfn,
                              verdict &gt;&gt; NF_VERDICT_BITS))
                        <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">next_hook</span>;
        }
        rcu_read_unlock();
        <span style="color: #00ffff;">return</span> ret;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2014-11-19 Wed 20:20</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
