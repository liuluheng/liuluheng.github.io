#+SETUPFILE: ~/.emacs.d/src/org-templates/level-1.org
#+TITLE: Filesystem OverView
#+OPTIONS: num:nil H:2


* General
** arago main page
http://arago-project.org/wiki/index.php/Main_Page
** angstrom
http://www.angstrom-distribution.org/
** busybox
http://www.busybox.net/
** ubuntu
https://wiki.ubuntu.com/ARM/RootfsFromScratch
** OpenEmbedded
http://www.openembedded.org/wiki/Main_Page
** Poky Linux
http://www.pokylinux.org/
** Root File system solutions
http://processors.wiki.ti.com/index.php/Linux_Toolchain#Root_File_System_solutions

** Creating a Root File System for Linux on OMAP35x
http://processors.wiki.ti.com/index.php/Creating_a_Root_File_System_for_Linux_on_OMAP35x
** Initrd
http://processors.wiki.ti.com/index.php/Initrd

* Modify
** Using The Correct Console Device
 update the =/etc/inittab= file in the filesystem used for kernel 
#+begin_src sh
S:2345:respawn:/sbin/getty 115200 ttyS2
by,
S:2345:respawn:/sbin/getty 115200 ttyO2
#+end_src
 
* Arago
** Setting Up Build Environment and build
*** ubuntu install dependency
#+begin_src sh
sudo apt-get install diffstat texi2html chrpath subversion python-psyco 
#+end_src 
*** Create the directory
Create a new directory for the build environment:
#+begin_src sh
$ mkdir $HOME/oe
$ cd $HOME/oe
#+end_src
*** Clone Arago repositories
Now check out the following repositories:
#+begin_src sh
$ git clone git://arago-project.org/git/arago.git
$ git clone git://arago-project.org/git/arago-oe-dev.git
$ git clone git://arago-project.org/git/arago-bitbake.git
#+end_src
The directory should now be populated with 3 subdirectories – =arago=, =arago-oe-dev= and =arago-bitbake=.
*** Copy setup/config files
Arago repository comes with samples of arago/setenv and
arago/conf/local.conf files, which you can use as a starting point, by
copying them into their actual names (without .sample extension) and
modifying to suit your needs:
#+begin_src s
$ cp arago/setenv.sample arago/setenv
$ cp arago/conf/local.conf.sample arago/conf/local.conf
#+end_src

+ File: =arago/setenv=
  Edit =arago/setenv= file and make sure environment variables are set
  properly. OEBASE should point to the directory you’ve created in the
  beginning:
#+begin_src sh
export OEBASE=$HOME/oe
#+end_src
+ File: =arago/setenv=
  Also, in order to use a separate "scratch" area outside of home
  directory, you may want to enable SCRATCH variable and point it
  appropriately:
#+begin_src sh
export SCRATCH=/sim/scratch_AID
#+end_src

*** Set the environment variables
#+begin_src sh
$ . arago/seten
#+end_src
Or, 
#+begin_src sh
$ source arago/setenv
#+end_src
*** Point to CSL toolchain
If not done before, set the PATH variable to point to the CodeSourcery
toolchain (refer to [[http://www.mentor.com/embedded-software/codesourcery][Getting CodeSourcery Toolchain]]([[http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/lite/?cmpid=7108&lite=arm&target_os=GNU%2FLinux&target_arch=ARM&returnURL=https%253A%252F%252Fsourcery.mentor.com%252FGNUToolchain%252Frelease858%253Flite%253Darm%2526cmpid%253D7108][The binary
distribution for 2009q1-203 version]]) for obtaining one):

#+begin_src sh
$ export PATH=/opt/arm-2009q1/bin:$PATH
#+end_src

*** Build a minimal base filesystem
Now it should be ready to start a build of the minimal filesystem
image:
#+begin_src sh
$ bitbake arago-base-image
#+end_src
*** Build a "demo" filesystem for OMAP3 EVM
#+begin_src sh
$ MACHINE=omap3evm bitbake arago-console-image
#+end_src
*** Build different kernels for supported platforms
#+begin_src sh
$ MACHINE=omap3evm bitbake virtual/kernel
$ MACHINE=beagleboard bitbake virtual/kernel
$ MACHINE=dm6446-evm bitbake virtual/kernel
$ MACHINE=dm355-evm bitbake virtual/kernel
#+end_src
*** High-level hierarchy of arago-deploy directory
Resulting images and packages will be placed under =arago-deploy=
directory - =images= for the filesystem, kernel and bootloader; and =ipk=
for binary IPK packages, respectively.

#+begin_src sh
arago-deploy
|-- images
|   |-- arago
|   |-- dm355-evm
|   |-- dm6446-evm
|   `-- omap3evm
|-- ipk
|   |-- all
|   |-- arago
|   |-- armv5te
|   |-- armv7a
|   |-- dm355-evm
|   |-- dm6446-evm
|   |-- i686
|   |-- i686-armv5te-sdk
|   |-- i686-armv7a-sdk
|   `-- omap3evm
`-- sdk
#+end_src

*** Build individual package recipes
You can also look in =oe/arago/recipes= for individual package recipes
that you can bitbake. For example:
#+begin_src sh
bitbake curl
bitbake thhtpd
#+end_src

*** build a native compiler (on dm8168) using
#+begin_src sh
MACHINE=c6a816x-evm ./arago-bitbake/bin/bitbake gcc-4.3.3(since codesourcery is using 4.3.3) or
MACHINE=c6a816x-evm ./arago-bitbake/bin/bitbake task-sdk-native
#+end_src
** Crosscompiling Outside of Arago
se the sound API of the ALSA (Advanced Linux Sound Architecture)
project and call it =sndtest.c=:
#+begin_src c++
#include <stdio.h>
#include <alsa/asoundlib.h>

int main()
{
        printf("Using ALSA %s\n", snd_asoundlib_version());
        return 0;
}
#+end_src
We need to get the header files and libraries for ALSA on our host
system in order to compile and link our sample application. Luckily,
everything we need is provided by Arago in form of ipk packages. Some
of the packages, like dynamic libraries, are installed to the Arago
filesystem. But header files and static libraries are not installed
and usually are part of the -dev packages.

Our sample application using ALSA API would require the following ipk
packages:
#+begin_src sh
alsa-dev_1.0.18-r0.1_armv5te.ipk
libasound2_1.0.18-r0.1_armv5te.ipk
alsa-lib-dev_1.0.18-r0.1_armv5te.ipk
#+end_src

=alsa-dev= provides all the header files. =libasound2= provides the
dynamic library (which is also installed on the Arago filesystem for
run-time operation). And =alsa-lib-dev= provides the necessary support
to link our application against the dynamic library.

But it is possible to extract package content without opkg using only
standard Linux tools (ar and tar) and don't worry about the package
database:
#+begin_src sh
$ ar -p alsa-dev_1.0.18-r0.1_armv5te.ipk data.tar.gz | tar -zx
$ ar -p libasound2_1.0.18-r0.1_armv5te.ipk data.tar.gz | tar -zx
$ ar -p alsa-lib-dev_1.0.18-r0.1_armv5te.ipk data.tar.gz | tar -zx
#+end_src

Above commands would extract the actual content of data.tar.gz inside
each of the ipk packages to the current directory, re-creating the
directory hierarchy of the target. Specifically, header files will be
placed under ./usr/include and libraries under ./usr/lib

The resulting command would look like:
#+begin_src sh
$ arm-none-linux-gnueabi-gcc -o sndtest sndtest.c -I./usr/include/ -L./usr/lib/ -lasound
#+end_src

** Creating recipes in Arago
Notes from
https://www.ridgerun.com/developer/wiki/index.php/Creating_recipes_in_Arago

*** Brief review of Arago directory layout

After setting up your build environment, your directory structure should look like this:
#+begin_src sh
   workspace
   |-arago
   |-arago-bitbake
   |-arago-oe-dev
   |-arago-custom
   |-arago-tmp
   `-dowloads
#+end_src

+ arago-custom: You should place your custom recipes here and also any
  overrides to recipes contained in 'arago' or 'arago-oe-dev'
  directories. Bitbake gives highest preference to the recipes in this
  directory, making it possible for you to override any functionality
  without having to touch directories under Arago control.
+ arago-tmp:This is where the build system keeps its working files and also where it places the output of the build. There's a lot going on here, so let's look at the top layer of the directory structure under arago-tmp:
  + cache: This is where bitbake caches information it obtains from parsing all available .bb files. You will not need to look in this directory.
  + stamps: This directory contains zero length files that are used to track each phase of the build as it is completed. You will normally not need to look in this directory.
  + cross: This directory contains the cross development tools for generating code for TI procesors.
  + staging: Header files, libraries, and other items needed by the build system are stored in this directory.
  + rootfs: After an image recipe build, this directory will contain the complete root file system for the image. This directory is suitable for nfs mounting.
  + deploy: This directory contains the final output of the build process: a set of images and ipkg files.
  + work:This appropriately named directory is where the real work gets done.  A subdirectory is created for each package that is built.There will typically be several subdirectories in each package working directory, let's look at the main ones:
  + <packagename-dir>:This is where the downloaded source code is expanded and patched. It will typically contain the source code for the package as well as any associated makefiles and documentation.
  + packages: This is where the build system places the files which will be packaged into ipkg files.The contents of each of these subdirectories is a root based tree of files exactly as they are to be installed in the target system.
  + tmp: This directory contains the scripts used to build the package and also the log files generated during the build process for the package. This is an extremely valuable debugging resource when you need to see exactly what the build system is doing.
  + image: There is normally no reason to look in this directory. It will contain the directory structure for the package installation, but without the actual files.
#+begin_src sh
  tmp
  |-cache
  |-stamps
  |-cross
  |-staging
  |-work
  |-rootfs
  `-deploy
#+end_src
*** Recipe Contents
    Besides descriptive information about the package, a recipe also includes:

+ The recipe's version
+ Dependent packages
+ Source code location
+ Patches if necessary
+ Instruction of how to configure and build the package files
+ Installation location on the target machine

*** Writting a recipe
**** Basic Variables
Recipes usually use names of the form: packagename_versionnumber.bb We
are going to use as example, sample-recipe_1.0.0.bb, its code is
presented below:
#+begin_src sh
 DESCRIPTION = "Sample program"
  PR = "r0"
  DEPENDS = ""
  
  SRC_URI = " \
  file://sample.c \
  "
  S = "${WORKDIR}"
  
  do_compile () {
  ${CC} ${CFLAGS} ${LDFLAGS} -o sample sample.c
  }
  
  do_install () {
  install -d ${D}${bindir}/
  install -m 0755 ${S}/sample ${D}${bindir}/
  }
  
  FILES_${PN} = "${bindir}/sample"
#+end_src
#+begin_verse
Variable          Description
PN
The package name. Determined from the recipe filename - everything up until the first underscore is considered to be the package name. For the sample-recipe_1.0.0.bb recipe the PN variable would be set to "sample-recipe".

PV
The package version. Determined from the recipe filename - everything between the first underscore and the final .bb is considered to be the package version. For the sample-recipe_1.0.0.bb recipe the PV variable would be set to "1.0.0". 

P
The package name and versions separated by a hyphen. For the sample-recipe_1.0.0.bb recipe the P variable would be set to "sample-recipe-1.0.0".

PR
The package release. This should be explicitly set in the recipe, if not set it defaults to "r0". 

WORKDIR
The working directory is where the source code is extracted, where files (other than patches) are copied, and where the logs and installation files are created. WORKDIR is initialized to PN-PV-PR, so for example recipe sample-recipe_1.0.0.bb, the value of WORKDIR would be set to "sample-recipe_1.0.0-r0" (assuming that the recipe set PR to "r0") 

S
This is the unpacked source directory.
Bitbake expects to find the extracted source for a package in a directory called packagename-version in the WORKDIR directory. This is the directory which it will change to before patching, compiling and installing the package.

For example, let's assume we have a package recipe called sample-recipe_1.0.0.bb and we are extracting the source from the sample-1.0.0.tar.gz file. Bitbake expects the source to end up in a directory called sample-1.0.0 within the WORKDIR.

If the source does not end up in this directory, then bitbake needs to be told this by explicitly setting S. 

D
This is the destination directory. It specifies where your package should be installed. The packaging system takes the contents of this directory and packages it for installation on the target.
The directory structure beneath D should reflect where the package files are to end up in the target system. For example, if a package file is intended to end up in /usr/bin on the target system, the recipe should install the files into ${D}/usr/bin.

It is considered poor practice to directly specify /usr/bin. The build system provides a set of variables that you should use instead (see table in Appendix). So for the example above, the proper installation directory specification would be ${D}${bindir} 

DESCRIPTION
Specifies the text that will be displayed by the package management system to describe what the package is.

MANTAINER   The name of the mantainer and usually an e-mail address

LICENSE	   The package license name

DEPENDS
If there were dependencies on any other packages to build or run, we would list them here. 

SRC_URI
Tell the build system where to find source code for the package

FILES_${PN}
Describes the list of files to be installed

RDEPENDS
A list of recommended packages to be installed
#+end_verse
**** Local sources and remote sources
specified the name of the source file "sample.c" with a file://
prefix, this is the way you must do it, if the source code is located
in the local file system.
#+begin_src sh
  SRC_URI = " \
  file://sample.c \
"
#+end_src

the case where the source code is fetched from a remote machine.
#+begin_src sh
 SRC_URI = " \
  http//www.mysite.com/downloads/sample-${PV}.tgz 
  "
#+end_src

A second change is possible because the build system sets the S
variable to ${WORKDIR}${P} by default. If the tarball is constructed
in the standard fashion, we are able to delete the line in our recipe
that used to explicity set S for the location of our source files.
**** Applying patches
#+begin_src sh
 SRC_URI = " \
  http//www.mysite.com/downloads/sample-${PV}.tgz\
  file://examplepatch.patch;patch=1 \
  "
#+end_src
**** Adding md5sum information
#+begin_src sh
 SRC_URI = "http//downloads.sourceforge.net/media_files.tar.gz;name=mediafiles"
  SRC_URI[mediafiles.md5sum] = "ffc705fc5581c584d88bd88a8b9caedf"
#+end_src

*** Possible command options
Bitbake normally acts on all metafiles defined in local.conf. It
resolves all dependencies and builds, what is needed. To be able to do
this, it first scans all directories given by the BBFILES entry in
local.conf and build a hash out of that.

#+begin_src sh
mrodriguez@optimus:~/devdirs/vaddio$ bitbake --help
.

Options:
 --version             show program's version number and exit
 -h, --help            show this help message and exit
  .
 .
 .
                       shell.
 -c CMD, --cmd=CMD     Specify task to execute. Note that this only executes
                       the specified task for the providee and the packages
                       it depends on, i.e. 'compile' does not implicitly call
                       stage for the dependencies (IOW: use only if you know
                       what you are doing). Depending on the base.bbclass a
                       listtasks tasks is defined and will show available
                       tasks
#+end_src
The following list gives an overview over the bitbake commands:

+ clean: cleans the package (tmp/work). Does not touch deploy dir (this has to be done manually).
+ fetch: fetches the package source from the source tree.
+ patch: eventually patches the sources with the patches provided in the package.
+ configure: configures the package. Knows several configure methods like autoconf/automake, qmake.
+ compile: compiles the package.
+ build: builds the package.
+ install: install the package.
+ package: packages the package.

In the sample-recipe code, there are specific instructions for the
commands: compile and install. Whether is a Makefile, those might not
be necessary.

#+begin_src sh
do_compile () {
${CC} ${CFLAGS} ${LDFLAGS} -o sample sample.c
}

do_install () {
install -d ${D}${bindir}/
install -m 0755 ${S}/sample ${D}${bindir}/
}
#+end_src

*** Appendix
#+begin_html
<table width="600" cellspacing="1" cellpadding="1" border="2" align="center">

<tbody><tr>
<th scope="col"> Variable name<br>
</th><th scope="col"> Definition<br>
</th><th scope="col"> Typical value<br>
</th></tr>
<tr>
<td> prefix<br>
</td><td> /usr <br>
</td><td> /usr <br>
</td></tr>
<tr>
<td> base_prefix<br>
</td><td> (empty) <br>
</td><td> (empty)<br>
</td></tr>
<tr>
<td> exec_prefix<br>
</td><td> ${base_prefix}<br>
</td><td> (empty)<br>
</td></tr>
<tr>
<td> base_bindir<br>
</td><td> ${base_prefix}/bin<br>
</td><td> /bin<br>
</td></tr>
<tr>
<td> base_sbindir<br>
</td><td> ${base_prefix}/sbin<br>
</td><td> /sbin<br>
</td></tr>
<tr>
<td> base_libdir<br>
</td><td> ${base_prefix}/lib<br>
</td><td> /lib<br>
</td></tr>
<tr>
<td> datadir <br>
</td><td> ${prefix}/share <br>
</td><td> /usr/share<br>
</td></tr>
<tr>
<td> sysconfdir <br>
</td><td> /etc<br>
</td><td> /etc<br>
</td></tr>
<tr>
<td> localstatedir<br>
</td><td> /var <br>
</td><td> /var<br>
</td></tr>
<tr>
<td> infodir <br>
</td><td> ${datadir}/info<br>
</td><td> /usr/share/info<br>
</td></tr>
<tr>
<td> mandir<br>
</td><td> ${datadir}/man<br>
</td><td> /usr/share/man<br>
</td></tr>
<tr>
<td> docdir <br>
</td><td> ${datadir}/doc<br>
</td><td> /usr/share/doc<br>
</td></tr>
<tr>
<td> servicedir<br>
</td><td> /srv <br>
</td><td> /srv<br>
</td></tr>
<tr>
<td> bindir<br>
</td><td> ${exec_prefix}/bin<br>
</td><td> /usr/bin<br>
</td></tr>
<tr>
<td> sbindir <br>
</td><td> ${exec_prefix}/sbin<br>
</td><td> /usr/sbin<br>
</td></tr>
<tr>
<td> libexecdir<br>
</td><td> ${exec_prefix}/libexec<br>
</td><td> /usr/libexec<br>
</td></tr>
<tr>
<td> libdir <br>
</td><td> ${exec_prefix}/lib<br>
</td><td> /usr/lib<br>
</td></tr>
<tr>
<td> includedir <br>
</td><td> ${exec_prefix}/include<br>
</td><td> /usr/include<br>
</td></tr></tbody></table>
#+end_html

* Angstrom
** Build
*** =python-numpy_1.4.1=
**** Error
Miss the libblas and liblapack 
**** Do
#+include: "./Files/Don-t-use-host-version-of-libblas-and-liblapack-for-python-numpy.patch" src sh

Then the result are:
=python-numpy_1.4.1.bb=
#+include: "./Files/python-numpy_1.4.1.bb" src sh
=00-numpy-1.4.1-no-atlas.patch=
#+include: "./Files/00-numpy-1.4.1-no-atlas.patch" src sh
*** =libnet_1.1.2.1.bb=
**** Error
#+begin_src sh
openembedded/recipes/libnet/libnet_1.1.2.1.bb md5sum error 

or

ERROR: Unable to unpack '/home/testbed/oe/sources/downloads/libnet_1.1.2.1.orig.tar.gz' to '/home/testbed/oe/build/tmp-angstrom_2010_x/work/armv7a-angstrom-linux-gnueabi/libnet-1.1.2.1-r4' (cmd: tar xz --no-same-owner -f /home/testbed/oe/sources/downloads/libnet_1.1.2.1.orig.tar.gz):
Execution of 'tar xz --no-same-owner -f
/home/testbed/oe/sources/downloads/libnet_1.1.2.1.orig.tar.gz' failed with exit code 2:

#+end_src
**** Do
+ delete the broken tar =downloads/libnet_1.1.2.1.orig.tar.gz=
+ download it from
  http://us.archive.ubuntu.com/ubuntu/pool/universe/libn/libnet/libnet_1.1.2.1.orig.tar.gz
+ compute the md5sum and correct =libnet_1.1.2.1.orig.tar.gz.md5=

*** =iproute2-2.6.38=
    Download from
=http://repository.timesys.com/buildsources/i/iproute2/iproute2-2.6.38/=

*** =debianutils_2.30.tar.gz=
Download from =http://www.openpandora.org/firmware/sources/=
*** =base-passwd_3.5.20.tar.gz=
from
=http://ftp.acc.umu.se/mirror/cdimage/snapshot/Debian/pool/main/b/base-passwd/=

* Host and Target
After setting up opkg respository and pointing it to apache webserver
with my vmware, now allows me easy install of python, dropbear, perl,
etc cross-complied using code sourcery.
#+begin_verse
On Host:
Install Apache sudo apt-get install apache2
After you finish building packages on host, refresh the package index on the host: > bitbake package-index
add a symlink to the arago deploy/ipk directory to apache's home page =/var/www/oe-repo=

On EVM:
Determine your host IP address, and then add a src/gz  line to =/etc/opkg/opkg.conf=
On the device, re-fetch the package list : opkg update
On the device, search for packages or install them
=opkg list '*strace*'=
=opkg install strace=
#+end_verse
* Notes
** Creating a Root File System for Linux on OMAP35x
http://processors.wiki.ti.com/index.php/Creating_a_Root_File_System_for_Linux_on_OMAP35x

*** create the directory
For simplicity, this note will
assume the user’s directory is “user”. The home directory is then
=/home/user=

All source code will be in the “src” directory, or
=/home/user/src=

Code will be built in the “build” directory, or
=/home/user/build=

The target root file system will be built in the “target” directory, or
=/home/user/target=

To create these directories, go to /home/user and enter
#+begin_src sh
[root@localhost user]# cd /home/user
[root@localhost user]# mkdir src
[root@localhost user]# mkdir build
[root@localhost user]# mkdir target
#+end_src

*** Configure the Linux Kernel to Support File Systems
The Linux kernel must be configured to support the file systems described in this note. To configure the kernel enter
“make menuconfig” on the command line.

**** Device Node Creation
The v2.6.22.x releases default to enabling =hotplug=, =sysfs=, and =tmpfs=.
To make sure hotplug is set, type in “make menuconfig” and from the
“Main menu” use the down arrow key to scroll down to the “General
setup” entry and press the Enter key to select it. Scroll down to
“Configure standard kernel features (for small systems)” and press the
Enter key. Scroll down to “Support for hot-pluggable devices” and make
sure it is set. The Space Bar selects and de-selects options. A sample
sub-menu is shown below:

#+begin_src sh
 ┌──────── Configure standard kernel features (for small systems) ─────────┐
 │  Arrow keys navigate the menu.  <Enter> selects submenus --->.          │
 │  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes, │
 │  <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> │
 │  for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < >       │
 │ ┌─────────────────────────────────────────────────────────────────────┐ │
 │ │    --- Configure standard kernel features (for small systems)       │ │
 │ │    [*]   Enable 16-bit UID system calls                             │ │
 │ │    [ ]   Sysctl syscall support                                     │ │
 │ │    [*]   Load all symbols for debugging/ksymoops                    │ │
 │ │    [ ]     Include all symbols in kallsyms                          │ │
 │ │    [*]     Do an extra kallsyms pass                                │ │
 │ │    [*]   Support for hot-pluggable devices                          │ │
 │ │    [*]   Enable support for printk                                  │ │
 │ │    [*]   BUG() support                                              │ │
 │ │    [*]   Enable ELF core dumps                                      │ │
 │ └────v(+)─────────────────────────────────────────────────────────────┘ │
 ├─────────────────────────────────────────────────────────────────────────┤
 │                    <Select>    < Exit >    < Help >                     │
#+end_src

To ensure sysfs and tmpfs are selected, start back at the “Main menu”
and scroll down to the “File systems” option. Press Enter to select it
and then scroll down to the “Pseudo filesystems” option and press
Enter to select it. The file systems selected here should be: /proc,
/proc/sys, sysfs, and “Virtual memory file system support.” That last
one is also referred to as /tmpfs. A sample sub-menu is shown below.
#+begin_src sh
 ┌────────────────────────── Pseudo filesystems ───────────────────────────┐
 │  Arrow keys navigate the menu.  <Enter> selects submenus --->.          │
 │  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes, │
 │  <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> │
 │  for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < >       │
 │ ┌─────────────────────────────────────────────────────────────────────┐ │
 │ │    [*] /proc file system support                                    │ │
 │ │    [*]   Sysctl support (/proc/sys)                                 │ │
 │ │    [*] sysfs file system support                                    │ │
 │ │    [*] Virtual memory file system support (former shm fs)           │ │
 │ │    [ ]   Tmpfs POSIX Access Control Lists                           │ │
 │ │    < > Userspace-driven configuration filesystem (EXPERIMENTAL)     │ │
 │ │                                                                     │ │
 │ │                                                                     │ │
 │ │                                                                     │ │
 │ │                                                                     │ │
 │ └─────────────────────────────────────────────────────────────────────┘ │
 ├─────────────────────────────────────────────────────────────────────────┤
 │                    <Select>    < Exit >    < Help >                     │
 └─────────────────────────────────────────────────────────────────────────┘
#+end_src
**** Configure the Linux Kernel for Root File System over NFS
From the “Main Menu” use the down arrow to scroll down to “File
systems” and select it by pressing the Enter key. Under “File Systems”
scroll down to “Network file systems” and select it. On this page make
sure that “NFS file system support”, “Provide NFSv3 client support”,
“Provide NFSv4 client support,” and “Root file system on NFS” are
selected. A sample sub-menu is shown below.

#+begin_src sh
┌───────────────────────── Network File Systems ──────────────────────────┐
 │  Arrow keys navigate the menu.  <Enter> selects submenus --->.          │
 │  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes, │
 │  <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> │
 │  for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < >       │
 │ ┌─────────────────────────────────────────────────────────────────────┐ │
 │ │    <*> NFS file system support                                      │ │
 │ │    [*]   Provide NFSv3 client support                               │ │
 │ │    [ ]     Provide client support for the NFSv3 ACL protocol extensi│ │
 │ │    [*]   Provide NFSv4 client support (EXPERIMENTAL)                │ │
 │ │    [ ]   Allow direct I/O on NFS files                              │ │
 │ │    < > NFS server support                                           │ │
 │ │    [*] Root file system on NFS                                      │ │
 │ │    [ ] Support for rpcbind versions 3 & 4 (EXPERIMENTAL)            │ │
 │ │    --- Secure RPC: Kerberos V mechanism (EXPERIMENTAL)              │ │
 │ │    < > Secure RPC: SPKM3 mechanism (EXPERIMENTAL)                   │ │
 │ └────v(+)─────────────────────────────────────────────────────────────┘ │
 ├─────────────────────────────────────────────────────────────────────────┤
 │                    <Select>    < Exit >    < Help >                     │
 └─────────────────────────────────────────────────────────────────────────┘
#+end_src
**** Configure the Linux Kernel for RAMDISK support
In this configuration the u-boot boot loader is used to download a
binary image to RAM and pass parameters to the kernel telling it the
root file system is on a ramdisk, where it is located, and its size.
From the “Main menu” scroll down to “Device Drivers” and select it.
Then scroll down to “Block devices” and select it. On this sub-menu
make sure “RAM disk support” is selected. For the “Default RAM disk
size” enter 16384. The RAM disk built in this note is 16M.
#+begin_src sh
 ┌───────────────────────────── Block devices ─────────────────────────────┐
 │  Arrow keys navigate the menu.  <Enter> selects submenus --->.          │
 │  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes, │
 │  <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> │
 │  for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < >       │
 │ ┌─────────────────────────────────────────────────────────────────────┐ │
 │ │    <*> Loopback device support                                      │ │
 │ │    < >   Cryptoloop Support                                         │ │
 │ │    < > Network block device support                                 │ │
 │ │    < > Low Performance USB Block driver                             │ │
 │ │    <*> RAM disk support                                             │ │
 │ │    (16)  Default number of RAM disks                                │ │
 │ │    (16384) Default RAM disk size (kbytes)                           │ │
 │ │    (1024) Default RAM disk block size (bytes)                       │ │
 │ │    < > Packet writing on CD/DVD media                               │ │
 │ │    < > ATA over Ethernet support                                    │ │
 │ └─────────────────────────────────────────────────────────────────────┘ │
 ├─────────────────────────────────────────────────────────────────────────┤
 │                    <Select>    < Exit >    < Help >                     │
 └─────────────────────────────────────────────────────────────────────────┘
#+end_src

The step above configures the kernel for build in a ramdisk. Now go
back to the “Main menu” and again select “General setup.” Scroll down
and make sure “Initial RAM filesystem and RAM disk (initramfs/initrd)
support” is selected. By default in the T.I. kernel it is.
#+begin_src sh
 ┌───────────────────────────── General setup ─────────────────────────────┐
 │  Arrow keys navigate the menu.  <Enter> selects submenus --->.          │
 │  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes, │
 │  <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> │
 │  for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < >       │
 │ ┌────^(-)─────────────────────────────────────────────────────────────┐ │
 │ │    [ ] Auditing support                                             │ │
 │ │    <*> Kernel .config support                                       │ │
 │ │    [*] Enable access to .config through /proc/config.gz             │ │
 │ │    (14) Kernel log buffer size (16 => 64KB, 17 => 128KB)            │ │
 │ │    [*] Create deprecated sysfs files                                │ │
 │ │    [ ] Kernel->user space relay support (formerly relayfs)          │ │
 │ │    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) suppor│ │
 │ │    ()    Initramfs source file(s)                                   │ │
 │ │    [*] Optimize for size (Look out for broken compilers!)           │ │
 │ │    [*] Configure standard kernel features (for small systems)  ---> │ │
 │ │        Choose SLAB allocator (SLAB)  --->                           │ │
 │ └─────────────────────────────────────────────────────────────────────┘ │
 ├─────────────────────────────────────────────────────────────────────────┤
 │                    <Select>    < Exit >    < Help >                     │
 └──────────────────────────────────────────────────────── ────────────────┘
#+end_src
**** Configure the Linux Kernel for Memory Technology Devices (MTD)
To use any of the flash file systems, such as JFFS2 or CRAMFS, the MTD
layer must be configured. MTD are typically flash devices used for
storage. Configuring the individual drivers can be tricky. If a device
is CFI compliant then all that is needed is to select the CFI options.
In this example, CFI is selected, as is Intel/Sharp just in case the
part it not CFI compliant. Starting at the “Main menu” scroll down to
“Device Drivers” and select it. Scroll down to “Memory Technology
Devices (MTD) support” and select it. There are numerous options that
can/should be selected. The screen captures below are length
#+begin_src sh
 ┌──────────────── Memory Technology Device (MTD) support ─────────────────┐
 │  Arrow keys navigate the menu.  <Enter> selects submenus --->.          │
 │  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes, │
 │  <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> │
 │  for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < >       │
 │ ┌─────────────────────────────────────────────────────────────────────┐ │
 │ │    --- Memory Technology Device (MTD) support                       │ │
 │ │    [ ]   Debugging                                                  │ │
 │ │    <*>   MTD concatenating support                                  │ │
 │ │    [*]   MTD partitioning support                                   │ │
 │ │    < >     RedBoot partition table parsing                          │ │
 │ │    [*]     Command line partition table parsing                     │ │
 │ │    < >     ARM Firmware Suite partition parsing                     │ │
 │ │    ---   User Modules And Translation Layers                        │ │
 │ │    <*>   Direct char device access to MTD devices                   │ │
 │ │    ---   Common interface to block layer for MTD 'translation layers│ │
 │ │    <*>   Caching block device access to MTD devices                 │ │
 │ │    < >   FTL (Flash Translation Layer) support                      │ │
 │ │    < >   NFTL (NAND Flash Translation Layer) support                │ │
 │ │    < >   INFTL (Inverse NAND Flash Translation Layer) support       │ │
 │ │    < >   Resident Flash Disk (Flash Translation Layer) support      │ │
 │ │    < >   NAND SSFDC (SmartMedia) read only translation layer        │ │
 │ │          RAM/ROM/Flash chip drivers  --->                           │ │
 │ │          Mapping drivers for chip access  --->                      │ │
 │ │          Self-contained MTD device drivers  --->                    │ │
 │ │    <*>   NAND Device Support  --->                                  │ │
 │ │    <*>   OneNAND Device Support  --->                               │ │
 │ │          UBI - Unsorted block images  --->                          │ │
 │ └─────────────────────────────────────────────────────────────────────┘ │
 ├─────────────────────────────────────────────────────────────────────────┤
 │                    <Select>    < Exit >    < Help >                     │
 └─────────────────────────────────────────────────────────────────────────┘
#+end_src
Select the “RAM/ROM/Flash chip drivers” and ensure CFI and Intel/Sharp
are selected.
#+begin_src sh
 ┌────────────────────── RAM/ROM/Flash chip drivers ───────────────────────┐
 │  Arrow keys navigate the menu.  <Enter> selects submenus --->.          │
 │  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes, │
 │  <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> │
 │  for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < >       │
 │ ┌─────────────────────────────────────────────────────────────────────┐ │
 │ │    <*> Detect flash chips by Common Flash Interface (CFI) probe     │ │
 │ │    < > Detect non-CFI AMD/JEDEC-compatible flash chips              │ │
 │ │    [ ] Flash chip driver advanced configuration options             │ │
 │ │    <*> Support for Intel/Sharp flash chips                          │ │
 │ │    < > Support for AMD/Fujitsu flash chips                          │ │
 │ │    < > Support for ST (Advanced Architecture) flash chips           │ │
 │ │    < > Support for RAM chips in bus mapping                         │ │
 │ │    < > Support for ROM chips in bus mapping                         │ │
 │ │    < > Support for absent chips in bus mapping                      │ │
 │ │                                                                     │ │
 │ │                                                                     │ │
 │ └─────────────────────────────────────────────────────────────────────┘ │
 ├─────────────────────────────────────────────────────────────────────────┤
 │                    <Select>    < Exit >    < Help >                     │
 └─────────────────────────────────────────────────────────────────────────┘
#+end_src
Finally, go back to the MTD menu and select the “Mapping drivers for
chip access” option. This option enables the partitioning of the MTD
into four partitions: u-boot, u-boot environment, kernel, and file
system.
#+begin_src sh
 ┌──────────────────── Mapping drivers for chip access ────────────────────┐
 │  Arrow keys navigate the menu.  <Enter> selects submenus --->.          │
 │  Highlighted letters are hotkeys.  Pressing <Y> includes, <N> excludes, │
 │  <M> modularizes features.  Press <Esc><Esc> to exit, <?> for Help, </> │
 │  for Search.  Legend: [*] built-in  [ ] excluded  <M> module  < >       │
 │ ┌─────────────────────────────────────────────────────────────────────┐ │
 │ │    [ ] Support non-linear mappings of flash chips                   │ │
 │ │    < > CFI Flash device in physical memory map                      │ │
 │ │    < > CFI Flash device mapped on ARM Integrator/P720T              │ │
 │ │    <*> TI OMAP board mappings                                       │ │
 │ │    < > Map driver for platform device RAM (mtd-ram)                 │ │
 │ │                                                                     │ │
 │ │                                                                     │ │
 │ └─────────────────────────────────────────────────────────────────────┘ │
 ├─────────────────────────────────────────────────────────────────────────┤
 │                    <Select>    < Exit >    < Help >                     │
 └─────────────────────────────────────────────────────────────────────────┘
#+end_src

*** Download and Build BusyBox
The source to BusyBox can be downloaded from
http://www.busybox.net/downloads. Download =busybox-1.20.2.tar.bz2= to the /home/user/src
directory. Change directory to the build directory and extract the
source code with the tar utility. 

#+begin_src sh
[root@localhost src]# cd ../build
[root@localhost build]# tar -xjvf ../src/busybox-1.20.2.tar.bz2
#+end_src

And then:
#+begin_src sh
[root@localhost build]# cd busybox-1.20.2
[root@localhost busybox-1.2.2.1]# make menuconfig
#+end_src

To build BusyBox, simply type in make at the command line. After a few
minutes the compile should be complete. When compilation is complete
install BusyBox to the target directory. The make and install commands
are show below:
#+begin_src sh
[root@localhost busybox-1.2.2.1]# make
[root@localhost busybox-1.2.2.1]# make CONFIG_PREFIX=/home/user/target install
#+end_src

*** Configure the New Target Root File System
Looking at the newly built root file system, there are only three
subdirectories of binaries and a symbolic link of bin/busybox to
linuxrc. More directories must be created before the file system can
be used. Some device nodes should be created, too.
#+begin_src sh
[root@localhost bin]# cd /home/user/target/
[root@localhost target]# dir
total 28
drwxr-xr-x  2 root root 4096 Nov 21 10:20 bin
lrwxrwxrwx  1 root root   11 Nov 21 10:20 linuxrc -> bin/busybox
drwxr-xr-x  2 root root 4096 Nov 21 10:20 sbin
drwxr-xr-x  4 root root 4096 Nov 21 10:20 usr
#+end_src
+ Create the dev, dev/pts, etc, etc/init.d, lib, mnt, opt, proc, root,
  sys, tmp, var, and var/log directories. Also create the device node
  for the initial console.
  #+begin_src sh
[root@localhost target]# mkdir dev
[root@localhost target]# mknod dev/console c 5 1
[root@localhost target]# mkdir dev/pts
[root@localhost target]# mkdir etc
[root@localhost target]# mkdir etc/init.d
[root@localhost target]# mkdir lib
[root@localhost target]# mkdir mnt
[root@localhost target]# mkdir opt
[root@localhost target]# mkdir proc
[root@localhost target]# mkdir root
[root@localhost target]# mkdir sys
[root@localhost target]# mkdir tmp
[root@localhost target]# mkdir var
[root@localhost target]# mkdir var/log
#+end_src
+ To have the /proc and /dev/pts file systems mounted at boot time,
  the file etc/fstab must be created in the etc directory. 
  #+begin_src sh
[root@localhost target]# cd etc
[root@localhost etc]# vi fstab
proc            /proc           proc    defaults        0 0
none            /dev/pts        devpts  mode=0622       0 0
#+end_src
+ The login utilities use the files group, hosts, and passwd in the
  etc directory for logging in. For now, only root needs to be defined
  in group and passwd while hosts just needs to have localhost
  defined. 
  #+begin_src sh
[root@localhost etc]# vi group
root:x:0:root

[root@localhost etc]# vi passwd
root::0:0:root:/root:/bin/ash 

[root@localhost etc]# vi hosts
127.0.0.1       localhost
#+end_src
+ The kernel starts “/sbin/init” after it boots.Init reads the
  etc/inittab file to determine what to do at start up, shutdown, or
  when a user logs in. These inittab files can get quite complicated.
  A simple one is shown below:
  #+begin_src sh
[root@localhost etc]# vi inittab
::sysinit:/etc/init.d/rcS 

# /bin/ash
#
# Start an "askfirst" shell on the serial port
console::askfirst:-/bin/ash

# Stuff to do when restarting the init process
::restart:/sbin/init

# Stuff to do before rebooting
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a -r
::shutdown:/sbin/swapoff -a
#+end_src
  The “sysinit” line tells init to run the /etc/init.d/rcS script to set
  up the system. 

  A simple etc/init.d/rcS file could assume file systems existed in the
  kernel and would simply mount the mount points as needed. A more
  complicated one would test for the existence of file systems and if
  found, mount them; if not found, find ways to still get the system
  booted.

  The author has taken the etc/init.d/rcS and mdev.conf files from the
  V2.6.22.18-OMAP3 release for a simple example. The rcS script will
  test for the existence of file systems and mount them accordingly.
  #+begin_src sh
[root@localhost etc]# vi init.d/rcS

#!/bin/sh
#   ---------------------------------------------
#   Common settings
#   ---------------------------------------------
HOSTNAME=OMAP3EVM
VERSION=1.0.0

hostname $HOSTNAME

#   ---------------------------------------------
#   Prints execution status.
#
#   arg1 : Execution status
#   arg2 : Continue (0) or Abort (1) on error
#   ---------------------------------------------
status ()
{
       if [ $1 -eq 0 ] ; then
               echo "[SUCCESS]"
       else
               echo "[FAILED]"

               if [ $2 -eq 1 ] ; then
                       echo "... System init aborted."
                       exit 1
               fi
       fi

}

#   ---------------------------------------------
#   Get verbose
#   ---------------------------------------------
echo ""
echo "    System initialization..."
echo ""
echo "    Hostname       : $HOSTNAME"
echo "    Filesystem     : v$VERSION"
echo ""
echo ""
echo "    Kernel release : `uname -s` `uname -r`"
echo "    Kernel version : `uname -v`"
echo ""


#   ---------------------------------------------
#   MDEV Support
#   (Requires sysfs support in the kernel)
#   ---------------------------------------------
echo -n " Mounting /proc             : "
mount -n -t proc /proc /proc
status $? 1

echo -n " Mounting /sys              : "
mount -n -t sysfs sysfs /sys
status $? 1

echo -n " Mounting /dev              : "
mount -n -t tmpfs mdev /dev
status $? 1

echo -n " Mounting /dev/pts          : "
mkdir /dev/pts
mount -t devpts devpts /dev/pts
status $? 1

echo -n " Enabling hot-plug          : "
echo "/sbin/mdev" > /proc/sys/kernel/hotplug
status $? 0

echo -n " Populating /dev            : "
mkdir /dev/input
mkdir /dev/snd

mdev -s
status $? 0

#   ---------------------------------------------
#   Disable power management
#   (Requires sysfs support in the kernel)
#   ---------------------------------------------
# echo -n " Disabling Power mgmt       : "
# echo -n "1" > /sys/power/cpuidle_deepest_state
# status $? 1

#   ---------------------------------------------
#   Turn off LCD after 1 hour of inactivity
#   (Requires sysfs support in the kernel)
#   ---------------------------------------------
# echo -n " Turn off LCD after 1 hour  : "
# echo -n "3600" > /sys/power/fb_timeout_value
# status $? 1


#   ---------------------------------------------
#   Mount the default file systems
#   ---------------------------------------------
echo -n " Mounting other filesystems : "
mount -a
status $? 0


#   ---------------------------------------------
#   Set PATH
#   ---------------------------------------------
export PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin


#   ---------------------------------------------
#   Start other daemons
#   ---------------------------------------------
echo -n " Starting syslogd           : "
/sbin/syslogd
status $? 0

echo -n " Starting telnetd           : "
/usr/sbin/telnetd
status $? 0


#   ---------------------------------------------
#   Done!
#   ---------------------------------------------
echo ""
echo "System initialization complete."


#   ---------------------------------------------
#   Start demo app
#   ---------------------------------------------
#if [[ -x /etc/init.d/demo_start ]]; then
#       echo " Starting Demo Application..."
#       /etc/init.d/demo_start &
#       sleep 5
#fi
Please note that in more recent kernels (2.6.29 and newer) the sysfs entries shown above to disable power management and control the LCD inactivity timeout shown above have been removed. For latest details on using OMAP Power Management in Linux please refer to this article.

To automatically mount the debugfs on start-up the following can be added to the above rcS file. Please note that the debugfs needs to be selected in the kernel configuration and built into the kernel before you can mount it. The below script checks to see if the debugfs is supported by the kernel before attempting to mount the file-system. To enable the debugfs run "make menuconfig" and go to "Kernel Hacking" and select "Debug Filesystem".

cat /proc/filesystems | grep -q debugfs
if [ $? -eq 0 ] ; then
        echo -n " Mounting /debug             : "
        mount -n -t debugfs none /debug
        status $? 1
fi
#+end_src
  
  To automatically mount the debugfs on start-up the following can be
  added to the above rcS file. Please note that the debugfs needs to
  be selected in the kernel configuration and built into the kernel
  before you can mount it. The below script checks to see if the
  debugfs is supported by the kernel before attempting to mount the
  file-system. To enable the debugfs run "make menuconfig" and go to
  "Kernel Hacking" and select "Debug Filesystem".
  #+begin_src sh
cat /proc/filesystems | grep -q debugfs
if [ $? -eq 0 ] ; then
        echo -n " Mounting /debug             : "
        mount -n -t debugfs none /debug
        status $? 1
fi
#+end_src
  After saving the file, change its access permissions so that it is executable for all.
  #+begin_src sh
[root@localhost etc]# vi mdev.conf

audio       0:5 0666
console     0:5 0600
control.*   0:0 0660 @/bin/mv /dev/$MDEV /dev/snd/
dsp         0:5 0666
event.*     0:0 0600 @/bin/mv /dev/$MDEV /dev/input/
fb          0:5 0666
nfs         0:5 0770
null        0:0 0777
pcm.*       0:0 0660 @/bin/mv /dev/$MDEV /dev/snd/
rtc         0:0 0666
tty         0:5 0660
tty0*       0:5 0660
tty1*       0:5 0660
tty2*       0:5 0660
tty3*       0:5 0660
tty4*       0:5 0660
tty5*       0:5 0660
tty6*       0:5 0660
ttyS*       0:5 0640
urandom     0:0 0444
zero        0:0 0666
#+end_src


*** Add the Shared Libraries Applications will Require
In the Code Sourcery tool chain, most of the libraries are found in
the =/home/testbed/CodeSourcery/Sourcery_G++_Lite/arm-none-linux-gnueabi/libc/lib= directory. Simply
copy these files to the root file system, maintaining symbolic links
and then strip out unneeded debug information.

#+begin_src sh
[root@localhost user]# cd /home/user/target/lib
[root@localhost lib]# cp –r /home/testbed/CodeSourcery/Sourcery_G++_Lite/arm-none-linux-gnueabi/libc/lib/* .
[root@localhost lib]# arm-none-linux-gnueabi-strip *
#+end_src
Some libraries might be in other directories in the tool chain; those
would have to be found on a “trial and error” basis when applications
do not load because of a missing shared library.
*** Mounting the Root File System over NFS
*** Enhancing the Root File System
Any drivers built as modules need to be added to the target root file
system
#+begin_src sh
[root@localhost 2.6_kernel]# make modules
[root@localhost 2.6_kernel]# make INSTALL_MOD_PATH=/home/user/target modules_install
#+end_src

One problem still exists – the modules still have debug information so
they are larger than they need to be. When debug information is no
longer needed, use the arm-none-linux-gnueabi-strip utility to remove
it. 
#+begin_src sh
[root@localhost user]# cd /home/user/target/lib/modules
[root@localhost modules]# arm-none-linux-gnueabi-strip `find . –name “*.ko”`
#+end_src

* Build FAQ
** Openembedded build cmake: Error running link command: No such file or directory
+ The errors are:
#+begin_src sh
| Linking CXX static library libcmsys.a
| cd /home/testbed/oe/arago-tmp/work/armv5te-none-linux-gnueabi/cmake-2.8.3-r2.1/cmake-2.8.3/Source/kwsys && /home/testbed/oe/arago-tmp/sysroots/i686-linux/usr/bin/cmake -P CMakeFiles/cmsys.dir/cmake_clean_target.cmake
| cd /home/testbed/oe/arago-tmp/work/armv5te-none-linux-gnueabi/cmake-2.8.3-r2.1/cmake-2.8.3/Source/kwsys && /home/testbed/oe/arago-tmp/sysroots/i686-linux/usr/bin/cmake -E cmake_link_script CMakeFiles/cmsys.dir/link.txt --verbose=1
| CMAKE_AR-NOTFOUND cr libcmsys.a  CMakeFiles/cmsys.dir/ProcessUNIX.o CMakeFiles/cmsys.dir/Base64.o CMakeFiles/cmsys.dir/MD5.o CMakeFiles/cmsys.dir/Terminal.o CMakeFiles/cmsys.dir/System.o CMakeFiles/cmsys.dir/String.o CMakeFiles/cmsys.dir/Directory.o CMakeFiles/cmsys.dir/DynamicLoader.o CMakeFiles/cmsys.dir/Glob.o CMakeFiles/cmsys.dir/RegularExpression.o CMakeFiles/cmsys.dir/SystemTools.o CMakeFiles/cmsys.dir/CommandLineArguments.o CMakeFiles/cmsys.dir/Registry.o CMakeFiles/cmsys.dir/IOStream.o CMakeFiles/cmsys.dir/SystemInformation.o
| Error running link command: No such file or directory
| make[2]: *** [Source/kwsys/libcmsys.a] Error 2
| make[2]: Leaving directory `/home/testbed/oe/arago-tmp/work/armv5te-none-linux-gnueabi/cmake-2.8.3-r2.1/cmake-2.8.3'
| make[1]: *** [Source/kwsys/CMakeFiles/cmsys.dir/all] Error 2
| make[1]: Leaving directory `/home/testbed/oe/arago-tmp/work/armv5te-none-linux-gnueabi/cmake-2.8.3-r2.1/cmake-2.8.3'
| make: *** [all] Error 2
| FATAL: oe_runmake failed
| ERROR: Function do_compile failed
NOTE: package cmake-2.8.3-r2.1: task do_compile: Failed
ERROR: TaskFailed event exception, aborting
ERROR: Build of /home/testbed/oe/arago-oe-dev/recipes/cmake/cmake_2.8.3.bb do_compile failed
ERROR: Task 15 (/home/testbed/oe/arago-oe-dev/recipes/cmake/cmake_2.8.3.bb, do_compile) failed with exit code 1
ERROR: '/home/testbed/oe/arago-oe-dev/recipes/cmake/cmake_2.8.3.bb' failed
ERROR: '/home/testbed/oe/arago-oe-dev/recipes/cmake/cmake_2.8.3.bb' failed
#+end_src
+ To do
  add the =arm-none-linux-gnueabi-ar= path to the =CMAKE_FIND_ROOT_PATH=
  
  In the file: =/home/testbed/oe/arago-oe-dev/classes/cmake.bbclass=
#+begin_src sh
  echo "set( CMAKE_FIND_ROOT_PATH ${STAGING_DIR_HOST} ${STAGING_DIR_NATIVE} ${STAGING_DIR_NATIVE}${prefix_native}/${BASE_PACKAGE_ARCH} "/home/testbed/CodeSourcery/Sourcery_G++_Lite" )" >> ${WORKDIR}/toolchain.cmake
#+end_src

** Openembedded build cmake: bin/ld: cannot find libncurses.so.5
+ The errors are like:
#+begin_src sh
oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/armv7a/lib/gcc/arm-oe-linux-uclibceabi/4.5.3/../../../../arm-oe-linux-uclibceabi/bin/ld: skipping incompatible /oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/lib/libexpat.so when searching for -lexpat
	/oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/armv7a/lib/gcc/arm-oe-linux-uclibceabi/4.5.3/../../../../arm-oe-linux-uclibceabi/bin/ld: skipping incompatible /oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/lib/libexpat.a when searching for -lexpat
	/oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/armv7a/lib/gcc/arm-oe-linux-uclibceabi/4.5.3/../../../../arm-oe-linux-uclibceabi/bin/ld: skipping incompatible /oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/lib/libz.so when searching for -lz
	/oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/armv7a/lib/gcc/arm-oe-linux-uclibceabi/4.5.3/../../../../arm-oe-linux-uclibceabi/bin/ld: skipping incompatible /oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/lib/libz.a when searching for -lz
	/oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/armv7a/lib/gcc/arm-oe-linux-uclibceabi/4.5.3/../../../../arm-oe-linux-uclibceabi/bin/ld: skipping incompatible /oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/lib/libcurl.so when searching for -lcurl
	/oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/armv7a/lib/gcc/arm-oe-linux-uclibceabi/4.5.3/../../../../arm-oe-linux-uclibceabi/bin/ld: skipping incompatible /oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/lib/libcurl.a when searching for -lcurl
	/oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/armv7a/lib/gcc/arm-oe-linux-uclibceabi/4.5.3/../../../../arm-oe-linux-uclibceabi/bin/ld: skipping incompatible /oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/lib/libncurses.so.5 when searching for libncurses.so.5
	/oe/build-minimal-uclibc/minimal-uclibc-dev/sysroots/i686-linux/usr/armv7a/lib/gcc/arm-oe-linux-uclibceabi/4.5.3/../../../../arm-oe-linux-uclibceabi/bin/ld: cannot find libncurses.so.5
#+end_src
+ To do
  Miss the DEPENDS: =ncures=, add `ncurses` to `DEPENDS` 
#+begin_src sh
--- a/recipes/cmake/cmake_2.8.3.bb
+++ b/recipes/cmake/cmake_2.8.3.bb
@@ -4,7 +4,7 @@ PR = "${INC_PR}.1"
 
 inherit cmake
 
-DEPENDS += "curl expat zlib libarchive"
+DEPENDS += "curl expat zlib libarchive ncurses"
 
 SRC_URI[md5sum] = "a76a44b93acf5e3badda9de111385921"
 SRC_URI[sha256sum] = "689ed02786b5cefa5515c7716784ee82a82e8ece6be5a3d629ac3cc0c05fc288"
#+end_src

** Openembedded: hang after this line "hwclock: can't open '/dev/misc/rtc':"
The system ends up with hang after:
#+begin_src sh
INIT: version 2.86 booting
Please wait: booting...
Starting udev

Root filesystem already rw, not remounting
logger: mount: mount point /proc/bus/usb does not exist
Caching udev devnodes
Populating dev cache
ALSA: Restoring mixer settings...
/usr/sbin/alsactl: load_state:1625: No soundcards found...
Configuring network interfaces... ifconfig: SIOCGIFFLAGS: No such device
ifconfig: SIOCGIFFLAGS: No such device
eth0      No such device

ifconfig: SIOCGIFFLAGS: No such device
done.
Starting portmap daemon: portmapportmap: fork: No such device.
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.all.rp_filter = 1
hwclock: can't open '/dev/misc/rtc': No such file or directory
Tue Mar 13 20:12:00 UTC 2012
hwclock: can't open '/dev/misc/rtc': No such file or directory
#+end_src
To fix the problem, follow those steps:[fn:1][fn:2]
#+begin_src sh
1. Go to udev receipes
$ cd ~/oe/openembedded/recipes/udev
 
2. Delete file udev_171.bb
$ rm udev_171.bb
 
3. Modify file udev_git.bb
Change PV = "171" to be PV = "162" (may older, the linux 2.6.37 uses the 141)

4. Modify ~/oe/openembedded/conf/distro/include/angstrom-2010-preferred-versions.inc
change from
PREFERRED_VERSION_udev = "171"
to
PREFERRED_VERSION_udev = "162"
 
5. Re-build udev
$ bitbake -f udev -c clean
$ bitbake -f udev -c configure     or (use task-base to replace task-base-extended)
Go to udev work directory and delete this portion from Makefile.am

		# ------------------------------------------------------------------------------

		# Bluetooth HID devices with special magic to switch the device

		# ------------------------------------------------------------------------------

		extras_hid2hci_hid2hci_SOURCES = extras/hid2hci/hid2hci.c

		extras_hid2hci_hid2hci_CPPFLAGS = $(AM_CPPFLAGS) $(LIBUSB_CFLAGS)

		extras_hid2hci_hid2hci_LDADD = libudev/libudev-private.la $(LIBUSB_LIBS)

		dist_udevrules_DATA += extras/hid2hci/70-hid2hci.rules

		libexec_PROGRAMS += extras/hid2hci/hid2hci

$ bitbake -f udev

6. We also need to fix udev verion 171 dependency from previous bitbake otherwise you will see this error
|  * satisfy_dependencies_for: Cannot satisfy the following dependencies for task-base:
|  *    libudev0 (>= 171) *
|  * opkg_install_cmd: Cannot install package task-base.

To find out what packages need to rebuild
cd /home/infocast35/stuff/build/tmp/deploy/eglibc/ipk/armv5te
$ for f in *.ipk; do ar p $f control.tar.gz | tar -zxO ./control|grep "libudev0 (>= 171)" && ls $f; done

Depends: libusb-0.1-4 (>= 0.1.3), libusb-1.0-0 (>= 1.0.8), libc6 (>= 2.12), libglib-2.0-0 (>= 2.28.5), libdbus-1-3 (>= 1.4.1), libreadline5 (>= 5.2), libudev0 (>= 171)
bluez4_4.98-r8.0.9_armv7a.ipk......

7. clean some packages
$ bitbake -f bluez4 -c clean
$ bitbake -f gstreamer -c clean
$ bitbake -f gst-plugins-base -c clean

8. ReRun
$ bitbake -c clean xxx-image
$ bitbake xxx-image
#+end_src

Note: 
1. udev 169 and up require kernel 2.6.36 for ARM
2. udev 162 may have conflict with bluez and hid2hci, may need to implement this fix http://git.kernel.org/?p=linux/hotplug/udev.git;a=commitdiff;h=07f1d2860e8ee393abaaead75a6ab3af0f10efbb

** Openembedded build: Cannot satisfy the following dependencies for task-base
Sometimes its required to downgrade a package version e.g. you are
suspecting that the problem is caused by udev version 171 so you would
like to build a root file system incrementally using udev 164

So you do required rituals of selecting 164 version of udev using PREFERRED_VERSION_udev = “164″

and then bitbake <your image>

and expectedly it should build your image again with udev 164 in it
but it may not happen and you might end up with errors like

#+begin_src sh
| Configuring udev.
| Configuring task-base-extended.
| Configuring sysvinit-pidof.
| Configuring tinylogin.
| Configuring sysvinit.
| Collected errors:
|  * satisfy_dependencies_for: Cannot satisfy the following dependencies for task-base:
|  *    libudev0 (>= 171) *
|  * opkg_install_cmd: Cannot install package task-base.
| ERROR: Function ‘do_rootfs’ failed (see /home/kraj/work/angstrom/build/tmp-angstrom_2010_x-uclibc/work/qemumips-angstrom-linux-uclibc/console-image-1.0-r0/temp/log.do_rootfs.15163 for further information)
NOTE: package console-image-1.0-r0: task do_rootfs: Failed
ERROR: Task 8 (/home/kraj/work/angstrom/sources/meta-angstrom/recipes-angstrom/images/console-image.bb, do_rootfs) failed with exit code ’1′
ERROR:
‘/home/kraj/work/angstrom/sources/meta-angstrom/recipes-angstrom/images/console-image.bb’
failed
#+end_src

The problem here is that there is a package which has created a
dependency on libudev0 >= 171 but now we are sysrooting with 164.
Ideally bitbake should have noticed it and rebuilt the concerned
recipe but it does not happen

+ To do
You need to figure out with package is wanting libudev0 171+
#+begin_src sh
$cd /home/testbed/oe/build/tmp-angstrom_2010_x/deploy/eglibc/ipk/armv7a
$ for f in *.ipk; do ar p $f control.tar.gz | tar -zxO ./control|grep“libudev0 (>= 171)” && ls $f; done

Depends: libusb-0.1-4 (>= 0.1.3), libusb-1.0-0 (>= 1.0.8), libc6 (>= 2.12), libglib-2.0-0 (>= 2.28.5), libdbus-1-3 (>= 1.4.1), libreadline5 (>= 5.2), libudev0 (>= 171)
bluez4_4.98-r8.0.9_armv7a.ipk
Depends: libgstinterfaces-0.10-0 (>= 0.10.32), gstreamer (>= 0.10.32), libgmodule-2.0-0 (>= 2.28.5), libxml2 (>= 2.7.8), libz1 (>= 1.2.3), libc6 (>= 2.12), libsm6 (>= 1.2.0), libuuid1 (>= 2.18), libice6 (>= 1.0.7), libxv1 (>= 1.0.6), libxext6 (>= 1.3.0), libx11-6 (>= 1.4.3), libxcb1 (>= 1.6), libpthread-stubs0 (>= 0.2), libxau6 (>= 1.0.6), libxdmcp6 (>= 1.1.0), libgudev-1.0-0 (>= 171), libudev0 (>= 171), libgobject-2.0-0 (>= 2.28.5), libgthread-2.0-0 (>= 2.28.5), libglib-2.0-0 (>= 2.28.5)
gst-plugin-video4linux_0.10.32-r11.1.9_armv7a.ipk => gst-plugins 
Depends: libdrm2 (>= 2.4.25), libc6 (>= 2.12), libkms1 (>= 2.4.25), libcairo2 (>= 1.10.0), libpixman-1-0 (>= 0.22.0), libfontconfig1 (>= 2.8.0), libexpat1 (>= 2.0.1), libfreetype6 (>= 2.4.3), libpng12-0 (>= 1.2.46), libxrender1 (>= 0.9.6), libx11-6 (>= 1.4.3), libxcb1 (>= 1.6), libpthread-stubs0 (>= 0.2), libxau6 (>= 1.0.6), libxdmcp6 (>= 1.1.0), libz1 (>= 1.2.3), libudev0 (>= 171)
libdrm-tests_2.4.25-r0.9_armv7a.ipk
#+end_src

So you know now the ipk which is depending on udev 171 and is being
pulled into the image
#+begin_src sh
$ bitbake -f bluez4 -c clean
$ bitbake -f gstreamer -c clean
$ bitbake -f gst-plugins-base -c clean
#+end_src


* Footnotes

[fn:1] http://www.purinux.org/blog/2012/03/openembedded-hang-after-this-line-hwclock-cant-open-devmiscrtc.html

[fn:2] http://www.purinux.org/blog/2012/03/how-to-create-oe-for-infocast35.html

